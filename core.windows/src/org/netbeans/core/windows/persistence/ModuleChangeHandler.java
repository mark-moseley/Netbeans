/*
 *                 Sun Public License Notice
 * 
 * The contents of this file are subject to the Sun Public License
 * Version 1.0 (the "License"). You may not use this file except in
 * compliance with the License. A copy of the License is available at
 * http://www.sun.com/
 * 
 * The Original Code is NetBeans. The Initial Developer of the Original
 * Code is Sun Microsystems, Inc. Portions Copyright 1997-2003 Sun
 * Microsystems, Inc. All Rights Reserved.
 */

package org.netbeans.core.windows.persistence;

import java.util.ArrayList;
import java.util.List;
import javax.swing.SwingUtilities;

import org.openide.ErrorManager;
import org.openide.filesystems.FileAttributeEvent;
import org.openide.filesystems.FileChangeListener;
import org.openide.filesystems.FileEvent;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileRenameEvent;
import org.openide.filesystems.FileStateInvalidException;
import org.openide.filesystems.FileSystem;
import org.openide.windows.WindowManager;

import org.netbeans.core.windows.Debug;
import org.netbeans.core.windows.WindowManagerImpl;

/**
 * Handler of changes in module folder. Changes can be for example
 * generated by enabling/disabling module which defines some winsys
 * element(s).
 * 
 * @author Marek Slama
 */
class ModuleChangeHandler implements FileChangeListener {
    
    private boolean started = false;
    
    private FileSystem fs = null;
    
    private FileObject modesModuleFolder;
    
    private FileObject groupsModuleFolder;
    
    /** Creates a new instance of ModuleChangeHandler */
    public ModuleChangeHandler() {
    }
    
    void startHandling () {
        if (started) {
            return;
        }
        PersistenceManager pm = PersistenceManager.getDefault();
        
        modesModuleFolder = pm.getModesModuleFolder();
        groupsModuleFolder = pm.getGroupsModuleFolder();
        try {
            fs = modesModuleFolder.getFileSystem();
        } catch (FileStateInvalidException exc) {
            ErrorManager em = ErrorManager.getDefault();
            em.log(ErrorManager.WARNING,
            "[WinSys.ModuleChangeHandler.startHandling]" // NOI18N
            + " Cannot get filesystem."); // NOI18N
            em.notify(ErrorManager.INFORMATIONAL,exc);
            return;
        }
        fs.addFileChangeListener(this);
        started = true;
    }
    
    void stopHandling () {
        if (!started) {
            return;
        }
        fs.removeFileChangeListener(this);
        fs = null;
        started = false;
    }

    /** Used to detect if FileEvent event is interesting for us.
     * @return true if event should be accepted
     */
    private boolean acceptEvent (FileObject fo) {
        FileObject parent = fo.getParent();
        if (parent == null) {
            return false;
        }
        //Change of mode config file or mode folder
        if (parent.getPath().equals(modesModuleFolder.getPath())) {
            log("++ MODE ++");
            return true;
        }
        //Change of mode config file or mode folder
        if (parent.getPath().equals(groupsModuleFolder.getPath())) {
            log("++ GROUP ++");
            return true;
        }
        parent = parent.getParent();
        if (parent == null) {
            return false;
        }
        //Change of tcRef config file
        if (parent.getPath().equals(modesModuleFolder.getPath())) {
            log("++ tcRef ++");
            return true;
        }
        //Change of tcGroup config file
        if (parent.getPath().equals(groupsModuleFolder.getPath())) {
            log("++ tcGroup ++");
            return true;
        }
        return false;
    }
    
    public void fileAttributeChanged (FileAttributeEvent fe) {
    }
    
    public void fileChanged (FileEvent fe) {
    }
    
    public void fileDataCreated (FileEvent fe) {
        FileObject fo = fe.getFile();
        boolean accepted = acceptEvent(fo);
        if (!accepted) {
            return;
        }
        log("-- fileDataCreated fo: " + fo
        + " isFolder:" + fo.isFolder()
        + " ACCEPTED"
        + " th:" + Thread.currentThread().getName());
        if (accepted && fo.isFolder()) {
            FileObject [] files = fo.getChildren();
            for (int i = 0; i < files.length; i++) {
                System.out.println("fo[" + i + "]: " + files[i]);
            }
        }
        processDataOrFolderCreated(fo);
    }
    
    public void fileFolderCreated (FileEvent fe) {
        FileObject fo = fe.getFile();
        boolean accepted = acceptEvent(fo);
        if (!accepted) {
            return;
        }
        log("-- fileFolderCreated fo: " + fo
        + " isFolder:" + fo.isFolder()
        + " ACCEPTED"
        + " th:" + Thread.currentThread().getName());
        if (accepted && fo.isFolder()) {
            FileObject [] files = fo.getChildren();
            for (int i = 0; i < files.length; i++) {
                log("fo[" + i + "]: " + files[i]);
            }
        }
        processDataOrFolderCreated(fo);
    }
    
    private void processDataOrFolderCreated (FileObject fo) {
        FileObject parent1 = fo.getParent();
        if (parent1.getPath().equals(modesModuleFolder.getPath())) {
            if (!fo.isFolder() && PersistenceManager.MODE_EXT.equals(fo.getExt())) {
                log("++ process MODE ADD ++");
                addMode(fo.getName());
            }
        } else if (parent1.getPath().equals(groupsModuleFolder.getPath())) {
            if (!fo.isFolder() && PersistenceManager.GROUP_EXT.equals(fo.getExt())) {
                log("++ process GROUP ADD ++");
                addGroup(fo.getName());
            }
        }
        FileObject parent2 = parent1.getParent();
        if (parent2.getPath().equals(modesModuleFolder.getPath())) {
            if (!fo.isFolder() && PersistenceManager.TCREF_EXT.equals(fo.getExt())) {
                log("++ process tcRef ADD ++");
                addTCRef(parent1.getName(), fo.getName());
            }
        } else if (parent2.getPath().equals(groupsModuleFolder.getPath())) {
            if (!fo.isFolder() && PersistenceManager.TCGROUP_EXT.equals(fo.getExt())) {
                log("++ process tcGroup ADD ++");
                addTCGroup(parent1.getName(), fo.getName());
            }
        }
    }
    
    public void fileDeleted (FileEvent fe) {
        FileObject fo = fe.getFile();
        boolean accepted = acceptEvent(fo);
        if (!accepted) {
            return;
        }
        
        log("-- fileDeleted fo: " + fo
        + " isFolder:" + fo.isFolder()
        + " isValid:" + fo.isValid()
        + " ACCEPTED"
        + " th:" + Thread.currentThread().getName());
        
        FileObject parent1 = fo.getParent();
        if (parent1.getPath().equals(modesModuleFolder.getPath())) {
            if (!fo.isFolder() && PersistenceManager.MODE_EXT.equals(fo.getExt())) {
                log("++ process MODE REMOVE ++");
                removeMode(fo.getName());
            }
        } else if (parent1.getPath().equals(groupsModuleFolder.getPath())) {
            if (!fo.isFolder() && PersistenceManager.GROUP_EXT.equals(fo.getExt())) {
                log("++ process GROUP REMOVE ++");
                removeGroup(fo.getName());
            }
        }
        FileObject parent2 = parent1.getParent();
        if (parent2.getPath().equals(modesModuleFolder.getPath())) {
            if (!fo.isFolder() && PersistenceManager.TCREF_EXT.equals(fo.getExt())) {
                log("++ process tcRef REMOVE ++");
                removeTCRef(fo.getName());
            }
        } else if (parent2.getPath().equals(groupsModuleFolder.getPath())) {
            if (!fo.isFolder() && PersistenceManager.TCGROUP_EXT.equals(fo.getExt())) {
                log("++ process tcGroup REMOVE ++");
                removeTCGroup(parent1.getName(), fo.getName());
            }
        }
    }
    
    public void fileRenamed (FileRenameEvent fe) {
    }
    
    private void addMode (String modeName) {
        log("addMode" + " mo:" + modeName);
        WindowManagerParser wmParser = PersistenceManager.getDefault().getWindowManagerParser();
        final ModeConfig modeConfig = wmParser.addMode(modeName);
        if (modeConfig != null) {
            // #37529 WindowsAPI to be called from AWT thread only.
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    WindowManagerImpl.getInstance().getPersistenceObserver().modeConfigAdded(modeConfig);
                }
            });
        }
    }
    
    private void addGroup (String groupName) {
        log("addGroup" + " group:" + groupName);
        WindowManagerParser wmParser = PersistenceManager.getDefault().getWindowManagerParser();
        final GroupConfig groupConfig = wmParser.addGroup(groupName);
        if (groupConfig != null) {
            // #37529 WindowsAPI to be called from AWT thread only.
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    WindowManagerImpl.getInstance().getPersistenceObserver().groupConfigAdded(groupConfig);
                }
            });
        }
    }
    
    private void addTCRef (final String modeName, String tcRefName) {
        log("addTCRef" + " modeName:" + modeName
        + " tcRefName:" + tcRefName);
        WindowManagerParser wmParser = PersistenceManager.getDefault().getWindowManagerParser();
        List tcRefNameList = new ArrayList(10);
        final TCRefConfig tcRefConfig = wmParser.addTCRef(modeName, tcRefName, tcRefNameList);
        if (tcRefConfig != null) {
            final String [] tcRefNameArray = (String []) tcRefNameList.toArray(new String[tcRefNameList.size()]);
            // #37529 WindowsAPI to be called from AWT thread only.
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    WindowManagerImpl.getInstance().getPersistenceObserver().topComponentRefConfigAdded(modeName, tcRefConfig, tcRefNameArray);
                }
            });
        }
    }
    
    private void addTCGroup (final String groupName, String tcGroupName) {
        log("addTCGroup" + " groupName:" + groupName
        + " tcGroupName:" + tcGroupName);
        WindowManagerParser wmParser = PersistenceManager.getDefault().getWindowManagerParser();
        final TCGroupConfig tcGroupConfig = wmParser.addTCGroup(groupName, tcGroupName);
        if (tcGroupConfig != null) {
            // #37529 WindowsAPI to be called from AWT thread only.
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    WindowManagerImpl.getInstance().getPersistenceObserver().topComponentGroupConfigAdded(groupName, tcGroupConfig);
                }
            });
        }
    }
    
    private void removeMode (final String modeName) {
        log("removeMode" + " mo:" + modeName);
        WindowManagerParser wmParser = PersistenceManager.getDefault().getWindowManagerParser();
        wmParser.removeMode(modeName);
        //Mode is not removed from model because it can already contain TCs added
        //by user using GUI eg.D&D.
        // #37529 WindowsAPI to be called from AWT thread only.
        //SwingUtilities.invokeLater(new Runnable() {
        //    public void run() {
        //      WindowManagerImpl.getInstance().getPersistenceObserver().modeConfigRemoved(modeName);
        //    }
        //});
    }
    
    private void removeGroup (final String groupName) {
        log("removeGroup" + " group:" + groupName);
        WindowManagerParser wmParser = PersistenceManager.getDefault().getWindowManagerParser();
        wmParser.removeGroup(groupName);
        // #37529 WindowsAPI to be called from AWT thread only.
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                WindowManagerImpl.getInstance().getPersistenceObserver().groupConfigRemoved(groupName);
            }
        });
    }
    
    private void removeTCRef (final String tcRefName) {
        log("removeTCRef" + " tcRefName:" + tcRefName);
        WindowManagerParser wmParser = PersistenceManager.getDefault().getWindowManagerParser();
        if (wmParser.removeTCRef(tcRefName)) {
            // #37529 WindowsAPI to be called from AWT thread only.
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    WindowManagerImpl.getInstance().getPersistenceObserver().topComponentRefConfigRemoved(tcRefName);
                }
            });
        }
    }
    
    private void removeTCGroup (final String groupName, final String tcGroupName) {
        log("removeTCGroup" + " groupName:" + groupName
        + " tcGroupName:" + tcGroupName);
        WindowManagerParser wmParser = PersistenceManager.getDefault().getWindowManagerParser();
        if (wmParser.removeTCGroup(groupName, tcGroupName)) {
            // #37529 WindowsAPI to be called from AWT thread only.
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    WindowManagerImpl.getInstance().getPersistenceObserver().topComponentGroupConfigRemoved(groupName, tcGroupName);
                }
            });
        }
    }
    
    void log (String s) {
        Debug.log(ModuleChangeHandler.class, s);
    }
    
}
