<!--
                Sun Public License Notice

The contents of this file are subject to the Sun Public License
Version 1.0 (the "License"). You may not use this file except in
compliance with the License. A copy of the License is available at
http://www.sun.com/

The Original Code is NetBeans. The Initial Developer of the Original
Code is Sun Microsystems, Inc. Portions Copyright 1997-2005 Sun
Microsystems, Inc. All Rights Reserved.
-->

<html>
<head>
<title>Modules API</title>
<link rel="stylesheet" href="../../../../prose.css" type="text/css">
</head>
<body>

<p class="overviewlink"><a href="../../../../overview-summary.html">Overview</a></p>

<h1>Javadoc</h1>

You may want to look at the

Javadoc,

particularly that for the

<a href="../ModuleInstall.html"><code>ModuleInstall</code></a>

class. Other classes in the package are generally not useful to module
authors.

<h1>Contents</h1>

<ul>

<li> <a href="#what-are">What Are Modules?</a>
<ul>
<li> <a href="#rel-std">Related standards</a>
</ul>

<li> <a href="#how-to">How to Create a New Module</a>
<ul>
<li> <a href="#how-jar">Build a JAR</a>
<li> <a href="#how-manifest">Writing the manifest</a>
<li> <a href="#how-main">Using a custom module class</a>
<ul>
<li> <a href="#installation-clean">"Installation-clean" modules</a>
</ul>
<li> <a href="#how-layer">Using an installation layer</a>
<li> <a href="#how-vers">Using versioning</a>
<li> <a href="#how-os-specific">Writing an OS dependent module</a>
</ul>

<li> <a href="#std-sec">Standard Module Sections</a>
<ul>
<li> <a href="#sec-action">Action</a>
<li> <a href="#sec-option">Option</a>
<li> <a href="#sec-loader">Data loader</a>
<li> <a href="#sec-executor">Service</a>
<li> <a href="#sec-filesystem">Filesystem</a>
<li> <a href="#sec-environment">Node</a>
<li> <a href="#sec-clipboardconvertor">Clipboard convertor</a>
</ul>

<li> <a href="#deploy">Deployment of Modules</a>
<ul>
<li> <a href="#related-files">Related Files</a>
<li> <a href="#deprecation">Deprecation</a>
<li> <a href="#refactoring">Refactoring</a>
<li> <a href="#downloading">Downloading</a>
<li> <a href="#order">Module install order</a>
<li> <a href="#listing">List of all modules</a>
<li> <a href="#security">Security</a>
<li> <a href="#jni">JNI</a>
</ul>

</ul>


<h1>Modules API</h1>

<div class="nonnormative">

<h2><a name="what-are">What are Modules?</a></h2>

<em>Modules</em> permit the IDE to be extended
dynamically. All of the Open APIs are designed to be used for purposes
of implementing modules. Modules may range in complexity from a single
Java class, properly packaged, to do something elementary such as add
a menu item to the Edit menu to display the contents of the clipboard;
to a full-scale integration of a major external application, such as a
Java profiling suite.

<p>All modules are distributed and installed as JAR files. The basic
format should be rather familiar; classes constituting the module are
<a href="#how-jar">archived in the JAR</a>, and special entries in the
<a href="#how-manifest">manifest file</a> are recognized by the IDE.

<h3><a name="rel-std">Related Standards</a></h3>

To the greatest extent possible, NetBeans has designed the module
system to reuse standard technologies when they are sufficient, and to
follow the style of others when not.

<p>The basic idea for the format of modules is taken from the

<a href="http://java.sun.com/products/j2se/1.4.2/docs/guide/extensions/index.html">Java Extension Mechanism</a>.

The basic ideas behind the

<a href="http://java.sun.com/products/j2se/1.4.2/docs/guide/versioning/index.html">Package Versioning Specification</a>

is used to <a href="#how-vers">handle dependencies</a> both between
modules and of modules to the system.

<p>All modules have some set of basic properties that indicate which
types of features they provide, which Java classes implement these
features, and what special option settings should be used when
installing these features into the IDE. Some of this information is
listed in the

<a href="http://java.sun.com/products/j2se/1.4.2/docs/guide/jar/manifest.html">manifest file</a>

using the customary format, and NetBeans-specific attributes. The

<a href="http://java.sun.com/beans/glasgow/jaf.html">Java Activation Framework</a>,

as well as JDK-internal features such as support for executable JAR
files, was used as a model for how to specify the useful contents of a
JAR in a data-driven fashion: many modules will need no special
installation code other than attributes in the manifest, and an XML layer
giving additional more specific deployment information.

</div>

<h2><a name="how-to">How to Create a New Module</a></h2>

<p>For basic cases, you should need to do very little to create a module
besides writing the basic source code.</p>

<p class="nonnormative">Please see a list of <a
href="../../doc-files/tips.html">tips</a> on writing modules,
installing them into the IDE, testing and debugging them.</p>

<h3><a name="how-jar">Build a JAR</a></h3>

<p>All module implementation classes must reside in a JAR file. If you
want to split up a large application into several pieces, perhaps
so as to make independent upgrades possible, you should do so by
creating multiple modules and relating them using <a
href="#how-vers">versioning</a>.</p>

<p class="nonnormative">To create the JAR, just use the standard JDK's

<a href="http://java.sun.com/products/j2se/1.4.2/docs/guide/jar/">JAR
tool</a>. You will need to add a custom manifest file, so use the
<code>-m</code> option to specify the additional contents. (Note that
<code>-m</code> will automatically merge the contents of your manifest
file with anything it would normally add, so e.g. signatures will be
automatically created properly.)</p>

<h3><a name="how-manifest">Writing the manifest</a></h3>

A module is recognized as such by the IDE, by virtue of its having
a special magic tag in the global section of the manifest:
<code>OpenIDE-Module</code>. Its value should be an arbitrary
identifier (with a format similar to that of a Java package name)
identifying the module for purposes of upgrades and
dependencies. You are encouraged (but not required) to use as this
tag the name of a Java package containing the principal classes for
the module; this ensures that there will not be conflicts between
modules produced by different developers or institutions, provided
that you follow the JavaSoft recommendations on naming packages
according to an Internet domain name you control. See the section
on <a href="#how-vers">versioning</a> for details on what this tag
is used for.

<p>There are a few other global tags which are optional but encouraged:

<dl>

<dt><code>OpenIDE-Module-Name</code>

<dd>Gives a human-presentable display name for the module. The name
may be localized by adding additional tags for each locale,
e.g. <code>OpenIDE-Module-Name_fr</code>.

<dt><code>OpenIDE-Module-Short-Description</code>

<dd>A short description of what the module does (about one sentence, like
a tool tip). May be localized as for the display name.

<dt><code>OpenIDE-Module-Long-Description</code>

<dd>A longer description of what the module does (roughly
paragraph-length). May be localized as for the display name.

<dt><code>OpenIDE-Module-Display-Category</code>

<dd>A phrase giving a category for the module. Modules with the same category may
be visually grouped together in various parts of the UI.
May be localized as for the display name.

<dt><code>OpenIDE-Module-Install</code>

<dd>The name of a <a href="#how-main">custom module class</a>.

<dt><code>OpenIDE-Module-Layer</code>

<dd>The name of an <a href="#how-layer">installation layer</a>.

<dt>Various versioning- and dependency-specific tags

<dd>Please see the section on <a href="#how-vers">versioning</a>
for details on these.

<dt><code>OpenIDE-Module-Module-Dependency-Message</code> and
    <code>OpenIDE-Module-Package-Dependency-Message</code>

<dd>Localizable pleasant messages to display to a user in case
a module or package dependency fails. In some cases it may be
quite normal for a dependency to fail and it is desirable to
provide a specific and helpful message to the user explaining
where to get the required dependency or why the module depending
on it is not needed by this user. May be localized as for the
display name. <em>Since 1.26</em>

<dt><code>OpenIDE-Module-Requires-Message</code>

<dd>As above, localizable pleasant message to display when a required
token is not found. <em>Since 2.3</em>

</dl>

The presentation-oriented tags (display name and category, short and
long description) may be in HTML if you prefer; this should be done in
the standard Swing fashion, by beginning the text with the magic
string <SAMP>&lt;html&gt;</SAMP>.

<p><em>Since 1.24:</em>
A more flexible way to provide human-readable information is to declare
the attribute <code>OpenIDE-Module-Localizing-Bundle</code>. Its value should
be the resource path to the (base locale of) a bundle file providing localizable
attributes for the module (display name, category, short and long description).
The bundle file may have localized variants as usual, and the keys should be the
same as the desired manifest attribute names, e.g. <code>OpenIDE-Module-Name</code>.
If it is necessary to localize an attribute from a section (currently only filesystem
sections with their <code>Display-Name</code> attribute), you may again place these
in the bundle, where the key will be prefixed by the section name and a slash, e.g.
<samp>org/foo/MyFileSystem.class/Display-Name</samp>.

<p>All other tags are bound to a particular <a href="#std-sec">module
section</a>. Naturally you may use other standard manifest attributes.</p>

<div class="nonnormative">

<p>In summary, here is an example manifest file that could be included
with the JAR tool's <code>-m</code> option:

<pre>
Manifest-Version: 1.0
OpenIDE-Module: com.modulemakers.clip_disp/2
OpenIDE-Module-Specification-Version: 2.0.1
OpenIDE-Module-Implementation-Version: 2.0-beta-rewrite
OpenIDE-Module-Build-Version: 2003-12-31 00:23 cron@buildhost.mycorp.com
OpenIDE-Module-Name: Clipboard Displayer
OpenIDE-Module-Name_cs: Prohlizec schranky
OpenIDE-Module-Install: com/modulemakers/clip_disp/Installer.class
OpenIDE-Module-Layer: com/modulemakers/clip_disp/Layer.xml
X-Comment-1: I am a comment (just a deliberately meaningless
X-Comment-2: header) - "Sealed" is a standard manifest attribute.
Sealed: true

Name: com/modulemakers/clip_disp/DisplayClipboardAction.class
OpenIDE-Module-Class: Action

</pre>

Module authors are strongly encouraged to use the

<a href="http://apisupport.netbeans.org/">API Support module</a>

which among other advantages, provides interactive parsing of
manifests that can help the beginning API developer immediately see
how the IDE will parse his manifest, including possible parse errors.

<p>If you have troubles with a manifest, check to make sure you have
the suggested extra blank line at the end. Some JDKs may have trouble
parsing it otherwise.

</div>

<h3><a name="how-main">Using a custom module class</a></h3>

With the <code>OpenIDE-Module-Install</code> attribute, you may specify
a custom class which will handle any complex aspects of the module's
installation (or uninstallation). This class is only necessary to
write if the <a href="#std-sec">standard module sections</a> and
<a href="#how-layer">layers</a> do not
cover everything you need to do. Even if you do write such a class,
standard sections and layers may still be used for any part of the module's
integration into the IDE which is conventional - the main class need
only handle the exceptional parts.

<p>To use a main install class, just extend the

<a href="../ModuleInstall.html"><code>ModuleInstall</code></a>

base class. Your class must be able to be

<a href="@JDK@/java/beans/Beans.html#instantiate(java.lang.ClassLoader,%20java.lang.String)">instantiated as a JavaBean</a>.

There are several methods which you may override, and may do anything
which is required to make the module cleanly enter and exit the
IDE.</p>

<div class="nonnormative">

<p>For example:

<pre>
package com.modulemakers.clip_disp;
import org.openide.modules.ModuleInstall;
import org.openide.filesystems.FileUtil;
import java.net.*;

public class ModuleHandler extends <a href="../ModuleInstall.html">ModuleInstall</a> {
  public void <a href="../ModuleInstall.html#installed()">installed</a>() {
    // This module has been installed for the first time! Notify authors.
    HttpURLConnection conn = (HttpURLConnection)
      (new URL ("http://www.modulemakers.com/clip_disp/installed.cgi").openConnection ());
    conn.getResponseCode ();
    conn.disconnect ();
    // Handle setup within this session too:
    restored ();
  }

  // Nothing special required here.
  // public void <a href="../ModuleInstall.html#restored()">restored</a>() {
  // }

  // Do not need to do anything special on uninstall.
  // Tools action will be removed automatically.
  // public void <a href="../ModuleInstall.html#uninstalled()">uninstalled</a>() {
  // }

  public boolean <a href="../ModuleInstall.html#closing()">closing</a>() {
    // Ask the user to save any open, modified clipboard contents.
    // If the user selects "Cancel" on one of these dialogs, don't exit yet!
    return DisplayClipboardAction.askAboutExiting ();
  }
}
</pre>

</div>

<p>The <code>installed</code> handler may do more or less what it
wishes - it will be called in a running IDE. The same applies to
<code>uninstalled</code> and <code>closing</code>. However,
<code>restored</code> is more delicate in that it may be called
during earlier phases of IDE initialization. Therefore, it should
not use presentation-oriented features of the IDE, such as the
Explorer or Window System APIs. However, the other APIs are
acceptable to use in <code>restored</code>, including
<code>DialogDisplayer</code>.

<p>The

<a href="../ModuleInstall.html#updated(int,%20java.lang.String)"><code>ModuleInstall.updated(...)</code></a>

method will be called just once when
a module is updated to a new version - when the new version is loaded
into the IDE for the first time (in a new session), the method is called
and the previous version number is accessible. Neither <code>installed</code>
nor <code>uninstalled</code> will be (automatically) called in this case.
It is a module author's responsibility to make sure that new versions of a
module are capable of "cleaning up" obsoleted installations created by older
versions, as far back as a user is likely to be directly upgrading.

<p>Some module installer classes may desire to keep state across
IDE sessions, for example if they require specific instructions on
what to uninstall that can only be gotten during the installation
process. All installers are automatically

<a href="@JDK@/java/io/Externalizable.html"><code>Externalizable</code></a>

and module authors may decide to override the two methods of this interface
to read and write its state from an
object source. Typically you would want to serialize and deserialize
<a href="@org-openide-util@/org/openide/util/SharedClassObject.html#getProperty(java.lang.Object)">shared class fields</a>
in the object using these methods.
It is a good idea to call the super methods as the first action when overriding.

<p>In some cases, a module relies on some external resource to be present
in order for it to be used. For example, an external application may need
to be installed in order for it to do anything. Or it may require a valid
license key. In such cases, the

<a href="../ModuleInstall.html#validate()"><code>ModuleInstall.validate()</code></a>

method may be overridden to check for this external resource and throw
a (preferably politely localized) <code>IllegalStateException</code>
if something is wrong. Throwing this exception will cancel the module installation
(or restoration) cleanly. Note that such an installer should not expect
anything related to the module to already be loaded when this method is
called, as it may be done when deciding whether to even begin loading.</p>

<div class="nonnormative">

<h4><a name="installation-clean">"Installation-clean" modules</a></h4>

Since the IDE can better manage modules when their resources are
declared to exist, rather than procedurally installed, it is desirable
to use declarative APIs whenever possible. Consider the following
definition of an "installation-clean module":

<ol>

<li>Either the module has no specified <code>ModuleInstall</code>; or

<li>It does have a <code>ModuleInstall</code> but this installer:

<ol>

<li>Does nothing of consequence during initialization of the
<code>ModuleInstall</code> object (static or instance fields with
initializers or initializer blocks or the <code>initialize</code>
method).

<li>Does not override the <code>readExternal</code> nor
<code>writeExternal</code> methods, nor any other related methods such
as <code>readResolve</code> or <code>writeReplace</code>. Thus it has
no externalized state.

<li>Does not override <code>installed</code> nor <code>updated</code>
(these will then just call <code>restored</code>).

<li>May override <code>uninstalled</code> but only to undo the effects
of <code>restored</code> or other changes made by the module in the
IDE while running. May override <code>closing</code> and/or
<code>close</code> but only to undo the effects of changes made by the
module while running.

<li>May override <code>restored</code> and/or <code>validate</code>.

</ol>

</ol>

Modules which are not installation-clean may not work as well in
conjunction with future "session" support for projects, and may
interfere with creation of "virgin" builds of the IDE (those that
merge module resources into an installation directory but do not
actually prime the IDE by running it once).

<p>Additionally it is recommended not to use <code>restored</code> to
add an object to the running IDE where use of the module layer would
suffice, nor to modify persistent state in <code>restored</code> or
<code>validate</code> that might affect a future call to the same
method. When possible it is best not to have a
<code>ModuleInstall</code> at all.

<p>Furthermore, the following practices should be avoided wherever
possible in order to simplify installation of the module from Auto
Update and via "ad-hoc" addition of the module JAR by a user (note
that mentioning options here does <em>not</em> imply that they are
officially supported by the APIs or even unofficially possible at any
particular time):

<ol>

<li>Including any libraries in the <samp>lib/ext/</samp> directory, as
these cannot be added to or reloaded while the IDE is running.

<li>Using the <samp>docs/</samp> directory as a place to store module
JavaHelp rather than inside the JAR.

<li>Using <code>Class-Path</code> from within the module JAR or its
extensions to point to resources which are not in or below the
directory containing the referring JAR (i.e. inclusion of
<samp>../</samp> or absolute paths).

<li>Including any files in the IDE installation other than the module
JAR in the <samp>modules/</samp> directory and any extensions declared
directly or indirectly via <code>Class-Path</code> beneath the
<samp>modules/</samp> directory (for example in
<samp>modules/ext/</samp>) and any locale variants of the above JARs;
except insofar as the presence of such files does not in and of itself
change the functionality of the IDE and is not required for the module
to operate (for example mounts of documentation ZIPs declared in the
layer); even then this is discouraged if there is an alternative as it
complicates ad-hoc module installation though Auto Update may be fine.

</ol>

</div>

<h3><a name="how-layer">Using an installation layer</a></h3>

<p>You may specify the global tag
<code>OpenIDE-Module-Layer</code> in addition to or instead of a
module main class; as a rule, use a layer for a particular task in
preference to a module installer, if you can. The tag value should
point to an XML file inside the module which is in the format
understood by <code>XMLFileSystem</code>.

Its contents specify some files that the module will add to the

<a href="@org-openide-filesystems@/org/openide/filesystems/Repository.html#getDefaultFileSystem()">system filesystem</a>

controlling much of the IDE's configuration. This filesystem is composed of many read-only XML layer filesystems
as well as a writable layer corresponding to the <code>config</code> subdirectory of the user directory.</p>

<p>The XML format is relatively simple. There is an

<a href="http://www.netbeans.org/dtds/filesystem-1_1.dtd">online DTD</a>

for it, but descriptively: the document element is
<samp>&lt;filesystem&gt;</samp> and corresponds to the root folder;
subfolders are represented with the <samp>&lt;folder&gt;</samp>
element; and files within folders with the <samp>&lt;file&gt;</samp>
element. Files and folders must have names, with the <samp>name</samp>
attribute. Files need not specify contents, in which case they will be
zero-length; or they may specify contents loaded from some other
resource (<samp>url</samp> attribute, treated as relative to the base
URL of the document itself); or for small textual contents, the
contents may be included inline inside the element, typically using
the <code>CDATA</code> syntax, though this usage is deprecated.
Attributes may be specified on folders
or files as empty <samp>&lt;attr&gt;</samp> elements; the name must be
supplied, and the value in one of several formats: primitive types,
strings, URLs, arbitrary serialized objects in hexadecimal, or
computed on the fly by calling the default constructor of some class,
or a static method (the method may be passed the file object in
question and/or the attribute name, if you wish).</p>

<div class="nonnormative">

<p>So as an example to install a template:

<pre>
&lt;?<font class="keyword">xml</font> <font class="variable-name">version</font>=<font class="constant">"1.0"</font>?&gt;
&lt;!<font class="keyword">DOCTYPE</font> <font class="type">filesystem</font> <font class="keyword">PUBLIC</font>
    <font class="constant">"-//NetBeans//DTD Filesystem 1.0//EN"</font>
    <font class="constant">"http://www.netbeans.org/dtds/filesystem-1_0.dtd"</font>&gt;
&lt;<font class="type">filesystem</font>&gt;
    &lt;<font class="type">folder</font> <font class="variable-name">name</font>=<font class="constant">"Templates"</font>&gt;
        &lt;<font class="type">folder</font> <font class="variable-name">name</font>=<font class="constant">"Other"</font>&gt;
            &lt;<font class="type">file</font> <font class="variable-name">name</font>=<font class="constant">"foo.txt"</font> <font class="variable-name">url</font>=<font class="constant">"actual-contents.txt"</font>&gt;
                <font class="comment">&lt;!-- Make it a template: --&gt;</font>
                &lt;<font class="type">attr</font> <font class="variable-name">name</font>=<font class="constant">"template"</font> <font class="variable-name">boolvalue</font>=<font class="constant">"true"</font>/&gt;
                <font class="comment">&lt;!-- Localized display name of data node: --&gt;</font>
                &lt;<font class="type">attr</font> <font class="variable-name">name</font>=<font class="constant">"SystemFileSystem.localizingBundle"</font>
                      <font class="variable-name">stringvalue</font>=<font class="constant">"com.foo.module.Bundle"</font>/&gt;
                <font class="comment">&lt;!-- HTML description of template for wizard to display: --&gt;</font>
                &lt;<font class="type">attr</font> <font class="variable-name">name</font>=<font class="constant">"templateWizardURL"</font>
                      <font class="variable-name">urlvalue</font>=<font class="constant">"nbresloc:/com/foo/module/foo-template-help.html"</font>/&gt;
                <font class="comment">&lt;!-- Set an iterator; complex object, so --&gt;</font>
                <font class="comment">&lt;!-- easiest to create thus: --&gt;</font>
                &lt;<font class="type">attr</font> <font class="variable-name">name</font>=<font class="constant">"templateWizardIterator"</font>
                      <font class="variable-name">newvalue</font>=<font class="constant">"com.foo.module.FooTemplateIterator"</font>/&gt;
            &lt;/<font class="type">file</font>&gt;
        &lt;/<font class="type">folder</font>&gt;
    &lt;/<font class="type">folder</font>&gt;
&lt;/<font class="type">filesystem</font>&gt;
</pre>

<p>where <code>FooTemplateIterator</code> contains a public constructor
taking no arguments.</p>

<p>The primary advantage of using layers is that they are declarative
rather than procedural, so you can install many kinds of extensions to
the IDE's behavior without any Java code, only XML. A related
advantage is that unlike <code>ModuleInstall</code>, there is no need
for multiple kinds of logic for module installation, restoration,
uninstallation, and upgrading; the "files" added by the layer are not
stored to disk and are loaded by the IDE in every session from the
XML, so when the module is uninstalled or upgraded its associated
files are correctly removed or changed, respectively, without any
extra work. (If the user customizes the files, however, their
customizations <em>are</em> stored to disk, and thus form a permanent
"patch" against the baseline configuration provided by the module.)
Not all parts of the IDE's configuration can be customized using files on
the system filesystem and thus by layers, but many things can.</p>

<p>Some common things that layers tend to be used for:</p>

<ol>

<li>Install

<a href="@org-openide-actions@/org/openide/actions/doc-files/api.html#adv-install">actions</a>

into the IDE's global menus, toolbars, or keymap.</li>

<li>Create templates in the folder <samp>Templates/</samp>.</li>

<li>Other things such as bookmarks, Component Palette beans, Welcome
panel buttons, and so on - according to the

<a href="http://www.netbeans.org/community/guidelines/installation.html#system">structure</a>

of the system filesystem.</li>

<li>Most generally, to install arbitrary
<a href="../../doc-files/services-api.html#instance-folders">services</a>
into the system.</li>

</ol>

</div>


<p>By default files listed in XML layers are not ordered in any
particular way, just as files found on disk would not have a
particular order. For purposes of some kinds of installation, it is
desirable to order data objects in data folders in a particular way -
for example, menus are

<a href="@org-openide-actions@/org/openide/actions/doc-files/api.html#install-menu">built from their menu items</a>

in the order the instance-bearing data objects occur in the data
folder. The call

<a href="@org-openide-loaders@/org/openide/loaders/DataFolder.html#setOrder(org.openide.loaders.DataObject[])"><code>DataFolder.setOrder(DataObject[])</code></a>

suffices to arbitrarily change folder order, but usually it is
desirable to create the proper order declaratively in the XML. For
this reason, <code>DataFolder</code> understands special attributes
(set on the <code>FileObject</code> forming the folder) which provide
<em>relative ordering constraints</em> on the objects in the folder.
Specifically: if there are data objects A and B in the folder,
represented by

<a href="@org-openide-loaders@/org/openide/loaders/DataObject.html#getPrimaryFile()">primary files</a>

<samp>afile</samp> and <samp>bfile</samp>, and there is an attribute
on the folder containing them named <samp>afile/bfile</samp> whose
value is <code>Boolean.TRUE</code>, then the folder will attempt to
place A before B in its ordering. For example, the XML:

<pre>
&lt;<font class="function-name">folder</font> <font class="variable-name">name</font>=<font class="string">"SomeFolder"</font>&gt;
    &lt;<font class="function-name">file</font> <font class="variable-name">name</font>=<font class="string">"first.txt"</font> <font class="variable-name">url</font>=<font class="string">"first.txt"</font>/&gt;
    &lt;<font class="function-name">attr</font> <font class="variable-name">name</font>=<font class="string">"first.txt/second.txt"</font> <font class="variable-name">boolvalue</font>=<font class="string">"true"</font>/&gt;
    &lt;<font class="function-name">file</font> <font class="variable-name">name</font>=<font class="string">"second.txt"</font> <font class="variable-name">url</font>=<font class="string">"second.txt"</font>/&gt;
&lt;/<font class="function-name">folder</font>&gt;
</pre>

will cause the IDE to try to keep <samp>first.txt</samp> before
<samp>second.txt</samp>. Things to remember:

<ol>

<li>Modules may provide layers some of whose files specify relative
constraints on files in the same folder position but installed by the
core, or other modules. That is fine and the constraints will be
honored - assuming the files being constrained both exist. Constraints
for which one or both of the affected files do not exist, are simply
ignored.

<li>It is fine to provide multiple constraints from a single file, for
example if there are several possible files it might need to be
installed after; all relevant constraints will be attempted.

<li>If constraints are contradictory, they may be ignored (and a
warning issued).

<li>If the user reorders the folder manually or
<code>DataFolder.setOrder(DataObject[])</code> is called, the explicit
order overrides the existing constraints. Subsequently added
constraints might have an effect, however.

<li>Only the names of <em>primary</em> files from data objects have
any bearing on the ordering.

<li>A constraint specifying that A comes before B does not force the
folder to place it <em>immediately</em> before B. If you want to
ensure that A in fact comes after some other files you know come
before B, thus trying to make them adjacent, this must be done
explicitly. Another module might explicitly interpose a file C between
A and B.

</ol>

<p>The resource path pointing to the layer is automatically localized
by the IDE every time the module is installed or restored; if there
are locale-specific variants, they are <em>merged</em> with the main
layer. More-specific variants can simply add files to the set
installed by the module; however they take precedence over the
less-specific variants, and thus can replace files, or even remove
(suppress) them, using <samp>*_hidden</samp> masks as used by

<a href="@org-openide-filesystems@/org/openide/filesystems/doc-files/api.html#multifs"><code>MultiFileSystem</code></a>.

In fact, if module A depends on module B, then A's layer(s) will take
precedence over B's layers, and it may replace or remove files
installed by B. In the same way, any module may replace or remove
files installed by the core.

<div class="nonnormative">

<h4>Display-oriented file attributes</h4>

<p>NetBeans recognizes two special file attributes, typically set in layers, which can improve UI.</p>

<dl>

<dt><code>SystemFileSystem.localizingBundle</code>

<dd><p>If set on a file object in the default filesystem serving as
the primary file for a data object, the data node's display name as
annotated by the filesystem will be taken from that resource bundle
(given as a string). The bundle will be found using

<a href="../../util/NbBundle.html#getBundle(java.lang.String)"><code>NbBundle.getBundle(String)</code></a>,

meaning that it should be of the form
<samp>org.domain.pkg.Bundle</samp> and will be found using the
default classloader and locale. The key in the bundle should be the
full resource path of the file.</p>

<dt><code>SystemFileSystem.icon</code>

<dd><p>If set on a file object on the default filesystem, the data
node as above will be given the 16x16 icon supplied by the attribute
value, given as a URL (<code>java.net.URL</code>, not
<code>java.lang.String</code>). Similarly
<code>SystemFileSystem.icon32</code> for the 32x32 icon, if desired.
A <code>java.awt.Image</code> may also be
given.</p>

</dl>

<p>By using these attributes, modules may provide a more pleasant and
localized user interface for files they install (typically via layer)
whose data nodes would be seen by a user (for example, templates or
services). If support for these file attributes is removed or
incompatibly changed in the future, such data nodes (and anything
driven by display aspects of data nodes, for example the labels of
menus created from folders beneath <samp>Menu/</samp>) will still
appear and be functional, however the names and icons will be
unattractive.</p>

</div>

<h3><a name="how-vers">Using versioning</a></h3>

Module <em>versioning</em> provides a way for modules to specify
which module they are (i.e. that one JAR is an upgrade from
another); which version they are; whether they have introduced
incompatible API changes since a previous version; and
(importantly) whether they depend on other modules or system
features, and if so how. While very simple modules may not require
special versioning support, this system should be used for any
module published on a general release schedule, or which it is
expected other modules may want to make use of.

<p>Modules can do three things with versioning:

<ol>

<li>Specify what they are. This is done by the special
<code>OpenIDE-Module</code> tag, whose value should be a unique
(programmatic) identifier for the module, as mentioned above. Not
be confused with the display name, which is free-form and may be
changed at will, this code name should not be changed
arbitrarily - pick a name and stick with it throughout module
releases.

<li>Specify which version they are. In line with the Java
Versioning Specification, modules can indicate two pieces of
version information about themselves using the
<code>OpenIDE-Module-Specification-Version</code> and the
<code>OpenIDE-Module-Implementation-Version</code> tags.
Modules are also permitted to use <code>OpenIDE-Module-Build-Version</code> to
give information about when or by whom they were physically built, in case there
is more specialized semantics given to the implementation version.

<li>Specify which features they depend on. Again, this is done
using the Versioning Specification - modules can request general or
specific versions of other modules
(<code>OpenIDE-Module-Module-Dependencies</code>), Java packages
(<code>OpenIDE-Module-Package-Dependencies</code>), Java itself
(<code>OpenIDE-Module-Java-Dependencies</code>), or the IDE
(<code>OpenIDE-Module-IDE-Dependencies</code>).

<p><em>As of 2.3</em> the tags
<code>OpenIDE-Module-Provides</code> and <code>OpenIDE-Module-Requires</code>
can also be used to specify dependencies between modules without naming
the exact module to depend on. A module may <em>provide</em> one or more
<em>tokens</em>. These are strings of conventional meaning, in the format of a Java
package or class name - perhaps taken to be the name of a class which will
be supplied to the lookup system, though there could be other meanings. A module
may also <em>require</em> one or more tokens. A module which requires some tokens
may only be enabled by the system if for each such token, there is at least one other
module which provides that token and is already enabled.

</ol>

At the heart of all these tags are the conventions used in the 

<a href="http://java.sun.com/products/j2se/1.4.2/docs/guide/versioning/index.html">Package Versioning Specification</a>

created by JavaSoft. While their documentation should be referred
to for the full details and justification of this system, the basic
idea is that features (modules) have two significant version identifiers: a
<em>specification</em> version, in Dewey-decimal format
(e.g. <code>1.2.1</code>), and an <em>implementation</em> version,
which is some free-form text. Specification versions may be
incremented to indicate compatible API extensions, in which case
the check to make sure that the feature requested is available may
be done using a (lexicographical) compare on the Dewey-decimal
numbers (e.g. <code>1.0</code> &lt; <code>1.0.1</code> &lt;
<code>1.1</code>). Implementation versions may be requested
according to an exact match only. Thus, specification versions are
generally used when you depend on some general and specified
behavior of another feature; implementation versions are used to
tie builds of different features together closely, as when you
maintain and release all the features yourself, and wish to
distribute them in a well-tested unit.

<p>(You may also specify a <em>build version</em> in your manifest,
typically giving a date. This is used only for diagnostic purposes and
is otherwise ignored by the module infrastructure.)</p>

<p>So, modules may specify either or both kinds of versions in
their manifest, and correspondingly request such versions from
other modules. (You may have at most one dependency between any single pair of modules, however.)
The Versioning Specification provides similar
numbering for (some, but not all) Java packages, as well as the
core Java Platform APIs and Virtual Machine Specification. The
IDE also has such versions which may be used to request a
general level of Open API support (using specification versions) or
a particular NetBeans build (using implementation versions).

<p>Since the Versioning Specification does not address incompatible
changes (those which would break existing code), but these are in
practice <em>occasionally</em> necessary (however painful), both
modules and the IDE itself may provide a separate integral number
giving the <em>incompatible release version</em>. You may only
request a particular release version, not subsequent ones, and you
<em>must</em> specify the release version if there is one
when giving <em>any module dependency</em>. It only differs
from a complete change of the feature in that the module installer
tool may prompt the user to make a "major upgrade" if a new release
version of a module is available.

<p><em>Since 2.3</em> a module dependency may also use a <em>range</em>
of release versions. The syntax is that in place of a single major release
version, you give a minimum then maximum version separated by dashes:

<pre>
OpenIDE-Module-Module-Dependencies: base.module/1-2 > 1.0
</pre>

<p>where the base module might either have the minimum major release
version (and the given specification version or later, if that is also
requested), or other major release versions up to the maximum (in
which case the specification version is irrelevant). You may not ask
for an implementation version with this syntax.

<p>To use all of these tags once you understand them is not too
hard. First of all, feature names: a module is named according to
the <code>OpenIDE-Module</code> tag, which should look like a Java
package name, but may be followed by a slash and release number
(e.g. <code>com.mycom.mymodule/3</code>); the IDE itself is named
<code>IDE</code>, again usually with a slash and release number;
Java packages are just named by the package name; the Java Platform
APIs are named by <code>Java</code>; and the Java Virtual Machine
by <code>VM</code>.

<p>Now, a module may list its own specification and/or
implementation versions using the tags above. To specify a
dependency on other features, it may use some or all of the four
dependency tags. The value of each will be a comma-separated list
of dependencies of that general type, each of which can be of the
form:

<dl>

<dd><b>FEATURENAME</b>

<dt>Just requests that the feature be present, not any particular
version. Useful for modules and Java packages (usually, Java
standard extensions) that need to be installed, but that is all.
This style is also used for requiring tokens, which cannot have versions.

<dd><b>FEATURENAME</b> <code>&gt;</code> <b>SPECVERSION</b>

<dt>Requests that the feature be present, that it state a
specification version, and that this version be greater than <strong>or
equal to</strong> the requested version. Note that you may not request
an exact specification version. This is the preferred form for module
dependencies.

<p>Remember, if requesting a dependency on a module which has a
release number, you <em>must</em> give that release number as part of
the feature name, whether or not you also ask for a specification
version.

<dd><b>FEATURENAME</b> <code>=</code> <b>IMPLVERSION</b>

<dt>Requests that the feature be present, that it state an
<em>implementation</em> version, and that this version exactly match the
requested one. Note that you may not request a comparison on implementation
versions, as they are generally non-numeric and not comparable.

</dl>

<div class="nonnormative">

<p>In summary, here is an (unlikely) example that specifies and
requests all sorts of versions:</p>

<pre>
OpenIDE-Module: com.mycom.mymodule/1
OpenIDE-Module-Specification-Version: 1.0.1
OpenIDE-Module-Implementation-Version: 1.0-release-g
OpenIDE-Module-Module-Dependencies:
 com.mycom.mysistermodule/1 = 1.0-release-g,
 com.othercom.anothermodule > 2.1,
 org.netbeans.modules.applet/1 > 1.0
OpenIDE-Module-Package-Dependencies: javax.television > 0.9
OpenIDE-Module-Java-Dependencies: Java = 1.2.1b4, VM > 1.0
OpenIDE-Module-IDE-Dependencies: IDE/1 > 1.0
OpenIDE-Module-Provides: javax.television.TunerProvider, javax.television.RemoteControl
OpenIDE-Module-Requires: org.netbeans.javahelp.api.Help
</pre>

</div>

<p>There is further special treatment for handling of package
dependencies for several reasons:

<ol>

  <li>In practice, the Java Versioning Specification is not all that
      widely followed, and many needed extensions will not list this
      information in their manifest.

  <li>Class loaders only define packages when the first class from that
      package is actually loaded. This makes it more difficult to verify
      whether a package is really there or not.

  <li>The standard manifest attribute <code>Class-Path</code> must be
      recognized and used; typically this attribute is used to actually add
      extensions to the module classloader, while the Modules API attributes
      are used to ensure that specific versions are available.

</ol>

<p>You may specify a sample class name in square brackets immediately
after the package name (or indeed instead of it). Giving a class name
together with a package name requests that the IDE first try to load
that class (it must be able to, so choose a class in the extension you
know will be there); then the versioning information is checked. (If
the sample class is simply in the desired package, you may omit the
package qualification as a shortcut.) This
addresses the second problem. Giving just a class name in square
brackets with no preceding package name indicates that the IDE should
only ensure that the named class is loadable, bypassing the Versioning
specification mechanisms. This addresses the first problem.</p>

<div class="nonnormative">

<p>Here then is a sample manifest which depends on an extension called
again <code>javax.television</code>, where it is known that a class
<code>javax.television.TunerProvider</code> is part of the package.
The extension is stored in <samp>modules/ext/television.jar</samp>
relative to the IDE's installation directory:

<pre>
OpenIDE-Module: com.mycom.mymodule/1
OpenIDE-Module-Package-Dependencies: javax.television[TunerProvider] > 0.9
Class-Path: ext/television.jar
</pre>

<p>Where can you get the version information to depend upon?

<ol>

<li>For installed modules, this information is listed in the
module's node in the Modules area under Session Settings.
This includes information about provided tokens.

<li>For packages, use the Java

<a href="@JDK@/java/lang/Package.html"><code>Package</code></a>

class, or examine the manifest of the JAR you depend upon.

<li>For the Java platform, use the system properties
<code>java.specification.version</code> and
<code>java.version</code>; for the VM,
<code>java.vm.specification.version</code> and
<code>java.vm.version</code>.

<li>For the IDE, this information is printed to the console when
the IDE starts up, and also appears in <code>netbeans.log</code>.

</ol>

</div>

<p><em>Important!</em> If your module has compile-time references
to classes in another module, you <em>must</em> specify a
direct dependency on that module using <code>OpenIDE-Module-Module-Dependencies</code>.
This ensures that the modules will be
installed in the correct order; otherwise a
<code>NoClassDefFoundError</code> or similar problem could result.

<p><em>Since 2.19</em> modules which provide Java-level APIs can
specify that only certain packages in the module form part of the
public API and should be accessible to other modules depending on
that module. The tag <code>OpenIDE-Module-Public-Packages</code>
is optional; if not present, <em>all</em> packages are considered
fair game. If present, it gives a list of package names to export
to other modules, for example:</p>
<pre>
OpenIDE-Module-Public-Packages: org.netbeans.api.foo.*
</pre>
<p>indicates that only classes (and resources) in the package
<code>org.netbeans.api.foo</code> should be available to client
modules. Attempts to use classes from other packages will fail,
for example with a <code>NoClassDefFoundError</code>.</p>

<p>More than one package can be given; separate them with
commas or spaces. A package name may end in <samp>.**</samp> rather
than <samp>.*</samp> to indicate that any subpackages are also exported,
rather than just the package itself. The special value <samp>-</samp>
(a single dash) indicates that <em>no</em> packages are to be exported.
(The module might still provide a non-Java-level API, for example by
defining and handling a custom XML DTD.)
"Private" classes and resources
may still be accessed using reflection from the system classloader,
just not from a module classloader.</p>

<a name="friend"></a>
<p>Additionally, sometimes a module with an API in public packages wishes to
provide access only to certain "friend" modules. This is
possible if the module declares public packages together with a list
of code base names of "friend" modules that can access them:
<pre>
OpenIDE-Module-Friends: org.foo, org.boo
</pre>
Only enumerated modules can access the public packages;
access from others is forbidden.</p>

<p>Additionally, sometimes a module wishes to get unrestricted access
to non-public packages of an API module. This is discouraged, but
possible if such module declares a <em>direct</em> dependency on the
API module using an implementation version dependency - this kind of
dependency indicates that the client module is prepared to track every
idiosyncrasy of the API module, and knows how to safely use undocumented
classes, as if both modules formed part of the same code base.</p>

<p class="nonnormative">Confused by all these restrictions on classloading? See the

<a href="../../doc-files/classpath.html">Class Path</a>

document which gives a fuller, more informal explanation.</p>

<h3><a name="how-os-specific">Writing an OS dependent module</a></h3>

<em>Since 4.44</em> a module can request to be enabled only on certain class
of an operating system 
(see issue <a href="http://www.netbeans.org/issues/show_bug.cgi?id=46833">46833</a>).
This is done by requesting a special token to be present and the system makes sure that
these tokens are enabled only when <em>NetBeans</em> run on requested class of OS.
<p>
The tokens supported in version 4.44 are:
<pre>
OpenIDE-Module-Requires: org.openide.modules.os.Windows
OpenIDE-Module-Requires: org.openide.modules.os.Unix
OpenIDE-Module-Requires: org.openide.modules.os.MacOSX
</pre>

<p class="nonnormative">
Please note, that Mac OS X is in fact also Unix, so requesting Unix also
enables your module on Mac OS X.
</p>

<p class="nonnormative">
So if one wants a module to be automatically enabled on Mac OS X and silently 
disabled on other platforms the best way is to create an eager module which 
requests the <code>MacOSX</code> token and the module system takes care of 
enabling it only on Mac OS X (as is the case of NetBeans 
<a href="http://www.netbeans.org/source/browse/ide/applemenu/manifest.mf?rev=1.2&content-type=text/x-cvsweb-markup">
applemenu module</a>).
</p>




<h2><a name="std-sec">Standard Module Sections</a></h2>

Standard module sections permit the use of common extensions to be
simplified, as the use of an explicit module main class is not
required for these. In each case, the class file implementing the
extension must have a manifest entry containing the
<code>OpenIDE-Module-Class</code> attribute, giving a code for the
extension type (see below); and may also have additional entries for
further customization.

<h3><a name="sec-action">Action</a></h3>

The class <code>Action</code> installs a system action into the
IDE. Refer to the

<a href="@org-openide-actions@/org/openide/actions/doc-files/api.html">Actions API</a>

for details on how to create an action. The class must implement

<a href="@org-openide-util@/org/openide/util/actions/SystemAction.html"><code>SystemAction</code></a>.

<p>By using this manifest section, your action will be available as
a "tool", i.e. it will appear (when enabled) in a list of all
extension tools in any popup menu (etc.) using

<a href="@org-openide-actions@/org/openide/actions/ToolsAction.html"><code>ToolsAction</code></a>.

Note that you <em>do not</em> need to use <code>ToolsAction</code>
directly for this purpose: it should already be attached as a popup
to all interesting nodes, as a menu item in the Tools menu,
etc. Just using the manifest tag ensures that your action will be
shown under such submenus.</p>

<div class="nonnormative">

<p><em>Note:</em> Actions may also be installed into fixed places
in the Main Window's menus and toolbars (this can also include
special components like palettes and so on), to keyboard shortcuts,
or to the default popup menu of a data loader you did not
write. The

<a href="@org-openide-actions@/org/openide/actions/doc-files/api.html#adv-install">Actions API</a>

describes how to do all of these things - they do not require
anything special in the manifest (besides use of a module install
class).

<p>Some types of actions make sense only for an object under your
direct control. For example, if you are writing a data loader, you
should specify which actions will be provided by default in its
data objects' popups. This type of use <em>does not</em> require
global installation; it can include standard IDE actions, as well
as your own. Please see the

<a href="@org-openide-actions@/org/openide/actions/doc-files/api.html#attach">Actions API</a>

for details on attaching an action to your own object.

<p>Also, as mentioned in the Actions API, it is good practice for
<em>all</em> actions implemented by modules to be copied into logical
subfolders of <samp>Actions/</samp> on the system filesystem (for
example using a module layer), since this folder is presented to the
user as a read-only "actions pool" they can use as a source of all
actions to customize their menus, toolbars, data object popup menus,
keyboard shortcuts, and so on.

</div>

<h3><a name="sec-loader">Loader</a></h3>

The class <code>Loader</code> installs a

<a href="@org-openide-loaders@/org/openide/loaders/DataLoader.html">data loader</a>

into the system

<a href="@org-openide-loaders@/org/openide/loaders/DataLoaderPool.html">loader pool</a>.

Refer to the

<a href="@org-openide-loaders@/org/openide/loaders/doc-files/api.html">Datasystems API</a>

for instructions on how to create a loader.

<p>There are a couple of options which may be used to specify the
relative precedence of data loaders, so that a more specific loader
may take precedence over a more general one:

<dl>

<dt><code>Install-Before: <i>classname</i></code>

<dd>Instructs the IDE to try to install this data loader before
another, so as to give it higher precedence: it will be given the
opportunity to scan over potential data objects first. The
<i>classname</i> should specify the <strong>representation class</strong> of the other
loader's

<a href="@org-openide-loaders@/org/openide/loaders/DataObject.html">data object</a>

type; see the

<a href="@org-openide-loaders@/org/openide/loaders/DataLoader.html#DataLoader(java.lang.Class)"><code>DataLoader</code> constructor</a>

for an explanation of how to use representation classes.
You may supply multiple class names separated by commas.

<dt><code>Install-After: <i>classname</i></code>

<dd>Exactly like <code>Install-Before</code>, except that the IDE will
attempt to install this loader <em>after</em> another, so as to give
it lower precedence.

</dl>

Either of <code>Install-Before</code> and
<code>Install-After</code> tags (if present) may fail to be honored
if there is no such registered data loader to compare to, or if the
tags are contradictory (imply a cyclic dependency); if so, the loader will still be installed.
By default a loader is placed at the end of the pool (i.e. lowest priority).
Note that these tags have <em>no
effect</em> on module install order or dependencies - for one thing,
loaders will be installed in the correct order regardless of which
order their providing modules are installed in.

<p>You need not specify module dependencies on other modules simply because you use
the names of data objects in those modules in your install before and after
tags; the ordering hints will simply be ignored unless and until the other
module is installed, at which time they will take effect.

<h2><a name="deploy">Deployment of Modules</a></h2>

<p>This section describes how a module may be deployed to a user's IDE.</p>

<h3><a name="related-files">Related Files</a></h3>

<p>Sometimes a module may need to bundle other files besides the
module JAR alongside it. No concrete mechanism for doing so is
specified in the Modules API. However, if there is such a mechanism,
then it is possible for the module to find these other files.

<a href="../InstalledFileLocator.html"><code>InstalledFileLocator</code></a>

permits such packaging mechanisms to let modules find their associated
files, as of 3.21.</p>

<p class="nonnormative">In the current implementation, modules may be
bundled with other files using

<a href="http://autoupdate.netbeans.org/nbm/nbm_package.html#structure">NBM files</a>

as provided by Auto Update, and the NetBeans build process premerges
modules in the selected module config into one large installation
directory, accessible via several system properties. Correspondingly,
the default locator finds files in this structure. The installation
structure might however change in the future, so
<code>InstalledFileLocator</code> is the only safe way to find such
bundled resources.</p>

<h3><a name="deprecation">Deprecation</a></h3>

<p>Sometimes you may have an API module which you wish to deprecate in its
entirely - it is only available for purposes of backwards compatibility.
Normally such modules are autoloads. To ensure that remaining clients of the
module are properly warned of its status, you may specify the
manifest attribute <code>OpenIDE-Module-Deprecated</code> with the value <code>true</code>.
Generally you should also supply a message using the localized manifest attribute
<code>OpenIDE-Module-Deprecation-Message</code>.
This
message may be displayed somehow if a non-deprecated module depending on your
deprecated module is enabled.</p>

<h3><a name="refactoring">Refactoring</a></h3>

<p>Sometimes as the developer of an API module, you may wish to make
major changes in how your APIs are laid out physically in modules.
Most commonly, you determine that it would be desirable to split one
big API module into several smaller pieces. However you wish to retain
compatibility for existing client modules, so that if they used your
old monolithic module, they will now automatically get access to the
newer, smaller pieces.</p>

<p>This is straightforward: create an XML file according to the DTD

<a href="http://www.netbeans.org/dtds/module-auto-deps-1_0.dtd"><code>-//NetBeans//DTD&nbsp;Module&nbsp;Automatic&nbsp;Dependencies&nbsp;1.0//EN</code></a>

and

<a href="#related-files">install it</a>

in the system filesystem under <samp>ModuleAutoDeps/</samp>
(<samp>system/ModuleAutoDeps/*.xml</samp>). Note that it will probably
<em>not</em> work to do this using an XML layer since the information
must be available before any module is even loaded.</p>

<p><em>As of 3.33</em></p>

<div class="nonnormative">

<h3><a name="downloading">Downloading</a></h3>

One scenario is that the user will just download the module from
the Web somewhere as a JAR file. The module may be stored to disk,
and either dropped into the IDE's <code>modules/</code> directory
(where it will be automatically installed upon the next IDE
restart) or manually installed from an arbitrary location using the
context menu on the <b>Modules</b> node in the options dialog. Children of this
node represent available modules and permit them to be dynamically
uninstalled or reinstalled.

<p>More user-friendly is the Update Center, a feature specific to
the NetBeans core implementation (i.e. its mechanism is not specified by
the APIs), which presents guided dialogs prompting users to
automatically upgrade modules or install new ones from an update server.
This functionality is provided by a <a href="http://autoupdate.netbeans.org/">module</a>.

<h4>Upgrades</h4>

Upgrades of modules can be customized by calling <code>ModuleInstall.updated()</code>.
This permits you to manually remove obsoleted actions, delete old
templates, etc. - remove anything not handled by the module manifest
which is nevertheless part of the IDE's persistent state.
With the advent of XML layers, most of these reasons for using <code>updated()</code>
have disappeared.

<p>A proper module will store all of its configurable state using

<a href="#sec-option">options</a>

(excepting service types, module externalization, etc.), and the
contents of these will be automatically carried over, one option at
a time (according to

<a href="@org-openide-options@/org/openide/options/SystemOption.html#getName()">option name</a>

and

<a href="@JDK@/java/beans/FeatureDescriptor.html#getName()">property name</a>)

into the new module version using Externalization - so as long as your
option values can be externalized and reread into the new version, you
need not worry. Similarly, if the

<a href="../ModuleInstall.html"><code>ModuleInstall</code></a>

class is externalizable and there is non-project state being stored
this way, you must ensure as usual that your externalization is
forward-compatible for upgrading to proceed smoothly.

</div>

<h3><a name="order">Module install order</a></h3>

It may be possible for multiple modules to be installed at once, or
for a module to specify a dependency which is not satisfied. How
does the IDE handle such cases?

<p>First of all, when the IDE starts up, all previously-installed
modules are restored, calling the <code>restored</code> methods on
their install classes if present. (Sections are installed before
this method is called.) If multiple modules are being restored
(which is normally the case), the IDE installs them in an
arbitrary order. However, if some of them specify
dependencies on other modules, the order may be adjusted so as to
make sure that the one specifying the dependency is installed after
the one it depends on.

<p>Now, when the IDE is running, modules may be installed into it,
possibly a cluster of them at once. In such a case, the IDE first
checks to make sure that all the prospective modules satisfy their
dependencies, either on system or Java features; already-installed
modules; or other modules in the prospective cluster. If any
modules fail their dependencies (or had syntactical errors in their
manifest files, etc.), they are removed from the list and the user
is given an explanation of what is missing. The remainder are then
ordered according to dependencies as above, and then installed in
that order.

<p><em>Caution:</em> it is forbidden to install modules which have
cyclic dependencies on one another, as the IDE would be unable to
determine which order to install them in! In fact, it will signal
an error and not install such modules. Generally such a situation
means that you should "factor out" the common required
functionality into a new module which the original ones will then
specify legal dependencies on.

<h3><a name="listing">List of all modules</a></h3>

Though a module should not generally need to know or care what other
modules are installed - anything it needs should be a dependency, and
anything which can use it, it should not know about - in a few cases it
is desirable to obtain the list of all modules in the system. This can
be easily accomplished as follows:

<pre>
Lookup.Template templ = new Lookup.Template(<a href="../ModuleInfo.html">ModuleInfo</a>.class);
Lookup.Result result = Lookup.getDefault().lookup(templ);
Collection modules = result.allInstances(); // Collection&lt;ModuleInfo&gt;
</pre>

The resulting <code>ModuleInfo</code> objects give basic information
about known modules (both enabled and disabled), such as their names
and versioning information, and current enablement status. This API is
strictly read-only and informational.

<p>A limited ability to modify the installation status of modules is
provided by the APIs as of version 1.31. In the folder
<samp>Modules/</samp> on the system filesystem, there will be XML
files corresponding to all known modules. In each case the name of the
XML file is derived from the code name base of the module with
<samp>.</samp> replaced by <samp>-</samp>, and followed by
<samp>.xml</samp>; for example,
<samp>org-netbeans-modules-properties.xml</samp>. The contents of the
XML file are given by a fixed

<a href="http://www.netbeans.org/dtds/module-status-1_0.dtd">DTD</a>.

<p>For purposes of the API, only parts of these files are defined. The
root element must be <code>&lt;module&gt;</code> and its
<code>name</code> attribute must be the code name base of the module.
Inside the root element are various <code>&lt;param&gt;</code>
elements, each with a name and some textual contents. The APIs define
only one parameter, <code>enabled</code>, which if present must be
either <code>true</code> or <code>false</code>.

<p>The APIs do not currently permit arbitrary changes to these files.
Specifically, addition or deletion of these files, or modification of
other files that may be in the same folder, is not permitted.
Modification of these files is permitted in only one way: if a module
XML file already contains the parameter <code>enabled</code>, you may
rewrite the file to be identical except with the opposite value of
this parameter. The module system will then make a best effort to
enable or disable the module accordingly (subject to dependencies and
other constraints).

<p class="nonnormative">Doing this is not recommended except in unusual circumstances, and
is intended primarily for session support to be able to enable and
disable modules via layer. If your module just needs to prevent itself
from being turned on under some circumstances (for example if it is
missing a valid license key), simply use
<code>ModuleInstall.validate</code>.</p>

<p>When rewriting the module XML be sure to use

<a href="@org-openide-filesystems@/org/openide/filesystems/FileSystem.html#runAtomicAction(org.openide.filesystems.FileSystem.AtomicAction)"><code>FileSystem.runAtomic(FileSystem.AtomicAction)</code></a>

to wrap the reading of the old XML and the writing of the new, to
prevent file changes from being fired halfway through.</p>

<div class="nonnormative">

<h3><a name="security">Security</a></h3>

In the current API there is no particular provision for security in
modules: all modules are assumed to be trusted, and have access to
all of the IDE's features (including the abilities of the Java VM
running as an application) if they require them. So, users should
not install arbitrary modules from potentially dangerous
sources. Given the density of callbacks and the fine-grained object
model of the APIs, providing a thread-based security model for API
code is not feasible.

<p>Code which creates new classloaders and loads other code indirectly
should, however, be aware that the created classloaders are generally
subject to regular security restrictions, unless code is loaded from
within the IDE installation, or certain forms of <code>NbClassLoader</code>
are used. When in doubt, explicitly define the protection domains for
classloaders you create.

<p>The IDE <em>currently</em> loads each module in its own classloader,
which means illegal dependencies between modules will result in errors.

<p>The Update Center supports certificate-based signing of
downloaded modules, so that the user can be sure that the contents
have not been tampered with or accidentally corrupted since their
creation.

</div>

<div class="nonnormative">

<h3><a name="jni">JNI</a></h3>

<p>There is an <em>unsupported</em> provision for
running modules making use of JNI native implementations inside
NetBeans. You may create a directory
<samp>modules/lib/</samp> (in either the installation or user
directories) and place native libraries (DLL or shared-object) there;
it will be added to the search path for calls to
<code>System.loadLibrary</code> made from module code. This avoids the
need to explicitly add some directory to the binary load path. The
module is entirely responsible for distinguishing between various
platforms and operating systems and requesting a library name
appropriate to the current one, however. Use of JNI is of course not
recommended and should be restricted to cases where it is unavoidable.</p>

<p>If a native library refers to <em>other</em> native libraries, they
are likely to be found using the normal search path for the platform.
This may mean that if you have several libraries used in a module, you
must either put all but the directly referenced one in the system's
global library search path, or merge them all together.</p>

<p><strong>Warning:</strong> since the JVM cannot load the same native
library twice even in different classloaders, a module making use of
this feature cannot be enabled more than once in a single VM session.
JARs loaded from the classpath (application classloader) are never
reloaded, so it may be possible to include the native-dependent
classes in such a JAR and make use of it from a module JAR.</p>

</div>

<hr>@FOOTER@

</body>
</html>
