
from test_support import verify, TestFailed, check_syntax

import warnings
<Attribute><Name>warnings</Name></Attribute>.<Call>filterwarnings</Call>("ignore", r"import \*", <Name>SyntaxWarning</Name>, "&lt;string&gt;")

print "1. simple nesting"

def <FunctionDef>make_adder</FunctionDef>(<Name>x</Name>):
    def <FunctionDef>adder</FunctionDef>(<Name>y</Name>):
        return <Name>x</Name> + <Name>y</Name>
    return <Name>adder</Name>

<Name>inc</Name> = <Call><Name>make_adder</Name></Call>(1)
<Name>plus10</Name> = <Call><Name>make_adder</Name></Call>(10)

<Call><Name>verify</Name></Call>(<Call><Name>inc</Name></Call>(1) == 2)
<Call><Name>verify</Name></Call>(<Call><Name>plus10</Name></Call>(-2) == 8)

print "2. extra nesting"

def <FunctionDef>make_adder2</FunctionDef>(<Name>x</Name>):
    def <FunctionDef>extra</FunctionDef>(): # check freevars passing through non-use scopes
        def <FunctionDef>adder</FunctionDef>(<Name>y</Name>):
            return <Name>x</Name> + <Name>y</Name>
        return <Name>adder</Name>
    return <Call><Name>extra</Name></Call>()

<Name>inc</Name> = <Call><Name>make_adder2</Name></Call>(1)
<Name>plus10</Name> = <Call><Name>make_adder2</Name></Call>(10)

<Call><Name>verify</Name></Call>(<Call><Name>inc</Name></Call>(1) == 2)
<Call><Name>verify</Name></Call>(<Call><Name>plus10</Name></Call>(-2) == 8)

print "3. simple nesting + rebinding"

def <FunctionDef>make_adder3</FunctionDef>(<Name>x</Name>):
    def <FunctionDef>adder</FunctionDef>(<Name>y</Name>):
        return <Name>x</Name> + <Name>y</Name>
    <Name>x</Name> = <Name>x</Name> + 1 # check tracking of assignment to x in defining scope
    return <Name>adder</Name>

<Name>inc</Name> = <Call><Name>make_adder3</Name></Call>(0)
<Name>plus10</Name> = <Call><Name>make_adder3</Name></Call>(9)

<Call><Name>verify</Name></Call>(<Call><Name>inc</Name></Call>(1) == 2)
<Call><Name>verify</Name></Call>(<Call><Name>plus10</Name></Call>(-2) == 8)

print "4. nesting with global but no free"

def <FunctionDef>make_adder4</FunctionDef>(): # XXX add exta level of indirection
    def <FunctionDef>nest</FunctionDef>():
        def <FunctionDef>nest</FunctionDef>():
            def <FunctionDef>adder</FunctionDef>(<Name>y</Name>):
                return <Name>global_x</Name> + <Name>y</Name> # check that plain old globals work
            return <Name>adder</Name>
        return <Call><Name>nest</Name></Call>()
    return <Call><Name>nest</Name></Call>()

<Name>global_x</Name> = 1
<Name>adder</Name> = <Call><Name>make_adder4</Name></Call>()
<Call><Name>verify</Name></Call>(<Call><Name>adder</Name></Call>(1) == 2)

<Name>global_x</Name> = 10
<Call><Name>verify</Name></Call>(<Call><Name>adder</Name></Call>(-2) == 8)

print "5. nesting through class"

def <FunctionDef>make_adder5</FunctionDef>(<Name>x</Name>):
    class <ClassDef>Adder</ClassDef>:
        def <FunctionDef>__call__</FunctionDef>(<Name>self</Name>, <Name>y</Name>):
            return <Name>x</Name> + <Name>y</Name>
    return <Call><Name>Adder</Name></Call>()

<Name>inc</Name> = <Call><Name>make_adder5</Name></Call>(1)
<Name>plus10</Name> = <Call><Name>make_adder5</Name></Call>(10)

<Call><Name>verify</Name></Call>(<Call><Name>inc</Name></Call>(1) == 2)
<Call><Name>verify</Name></Call>(<Call><Name>plus10</Name></Call>(-2) == 8)

print "6. nesting plus free ref to global"

def <FunctionDef>make_adder6</FunctionDef>(<Name>x</Name>):
    global global_nest_x
    def <FunctionDef>adder</FunctionDef>(<Name>y</Name>):
        return <Name>global_nest_x</Name> + <Name>y</Name>
    <Name>global_nest_x</Name> = <Name>x</Name>
    return <Name>adder</Name>

<Name>inc</Name> = <Call><Name>make_adder6</Name></Call>(1)
<Name>plus10</Name> = <Call><Name>make_adder6</Name></Call>(10)

<Call><Name>verify</Name></Call>(<Call><Name>inc</Name></Call>(1) == 11) # there's only one global
<Call><Name>verify</Name></Call>(<Call><Name>plus10</Name></Call>(-2) == 8)

print "7. nearest enclosing scope"

def <FunctionDef>f</FunctionDef>(<Name>x</Name>):
    def <FunctionDef>g</FunctionDef>(<Name>y</Name>):
        <Name>x</Name> = 42 # check that this masks binding in f()
        def <FunctionDef>h</FunctionDef>(<Name>z</Name>):
            return <Name>x</Name> + <Name>z</Name>
        return <Name>h</Name>
    return <Call><Name>g</Name></Call>(2)

<Name>test_func</Name> = <Call><Name>f</Name></Call>(10)
<Call><Name>verify</Name></Call>(<Call><Name>test_func</Name></Call>(5) == 47)

print "8. mixed freevars and cellvars"

def <FunctionDef>identity</FunctionDef>(<Name>x</Name>):
    return <Name>x</Name>

def <FunctionDef>f</FunctionDef>(<Name>x</Name>, <Name>y</Name>, <Name>z</Name>):
    def <FunctionDef>g</FunctionDef>(<Name>a</Name>, <Name>b</Name>, <Name>c</Name>):
        <Name>a</Name> = <Name>a</Name> + <Name>x</Name> # 3
        def <FunctionDef>h</FunctionDef>():
            # z * (4 + 9)
            # 3 * 13
            return <Call><Name>identity</Name></Call>(<Name>z</Name> * (<Name>b</Name> + <Name>y</Name>))
        <Name>y</Name> = <Name>c</Name> + <Name>z</Name> # 9
        return <Name>h</Name>
    return <Name>g</Name>

<Name>g</Name> = <Call><Name>f</Name></Call>(1, 2, 3)
<Name>h</Name> = <Call><Name>g</Name></Call>(2, 4, 6)
<Call><Name>verify</Name></Call>(<Call><Name>h</Name></Call>() == 39)

print "9. free variable in method"

def <FunctionDef>test</FunctionDef>():
    <Name>method_and_var</Name> = "var"
    class <ClassDef>Test</ClassDef>:
        def <FunctionDef>method_and_var</FunctionDef>(<Name>self</Name>):
            return "method"
        def <FunctionDef>test</FunctionDef>(<Name>self</Name>):
            return <Name>method_and_var</Name>
        def <FunctionDef>actual_global</FunctionDef>(<Name>self</Name>):
            return <Call><Name>str</Name></Call>("global")
        def <FunctionDef>str</FunctionDef>(<Name>self</Name>):
            return <Call><Name>str</Name></Call>(<Name>self</Name>)
    return <Call><Name>Test</Name></Call>()

<Name>t</Name> = <Call><Name>test</Name></Call>()
<Call><Name>verify</Name></Call>(<Attribute><Name>t</Name></Attribute>.<Call>test</Call>() == "var")
<Call><Name>verify</Name></Call>(<Attribute><Name>t</Name></Attribute>.<Call>method_and_var</Call>() == "method")
<Call><Name>verify</Name></Call>(<Attribute><Name>t</Name></Attribute>.<Call>actual_global</Call>() == "global")

<Name>method_and_var</Name> = "var"
class <ClassDef>Test</ClassDef>:
    # this class is not nested, so the rules are different
    def <FunctionDef>method_and_var</FunctionDef>(<Name>self</Name>):
        return "method"
    def <FunctionDef>test</FunctionDef>(<Name>self</Name>):
        return <Name>method_and_var</Name>
    def <FunctionDef>actual_global</FunctionDef>(<Name>self</Name>):
        return <Call><Name>str</Name></Call>("global")
    def <FunctionDef>str</FunctionDef>(<Name>self</Name>):
        return <Call><Name>str</Name></Call>(<Name>self</Name>)

<Name>t</Name> = <Call><Name>Test</Name></Call>()
<Call><Name>verify</Name></Call>(<Attribute><Name>t</Name></Attribute>.<Call>test</Call>() == "var")
<Call><Name>verify</Name></Call>(<Attribute><Name>t</Name></Attribute>.<Call>method_and_var</Call>() == "method")
<Call><Name>verify</Name></Call>(<Attribute><Name>t</Name></Attribute>.<Call>actual_global</Call>() == "global")

print "10. recursion"

def <FunctionDef>f</FunctionDef>(<Name>x</Name>):
    def <FunctionDef>fact</FunctionDef>(<Name>n</Name>):
        if <Name>n</Name> == 0:
            return 1
        else:
            return <Name>n</Name> * <Call><Name>fact</Name></Call>(<Name>n</Name> - 1)
    if <Name>x</Name> &gt;= 0:
        return <Call><Name>fact</Name></Call>(<Name>x</Name>)
    else:
        raise <Name>ValueError</Name>, "x must be &gt;= 0"

<Call><Name>verify</Name></Call>(<Call><Name>f</Name></Call>(6) == 720)


print "11. unoptimized namespaces"

<Call><Name>check_syntax</Name></Call>("""\
def unoptimized_clash1(strip):
    def f(s):
        from string import *
        return strip(s) # ambiguity: free or local
    return f
""")

<Call><Name>check_syntax</Name></Call>("""\
def unoptimized_clash2():
    from string import *
    def f(s):
        return strip(s) # ambiguity: global or local
    return f
""")

<Call><Name>check_syntax</Name></Call>("""\
def unoptimized_clash2():
    from string import *
    def g():
        def f(s):
            return strip(s) # ambiguity: global or local
        return f
""")

# XXX could allow this for exec with const argument, but what's the point
<Call><Name>check_syntax</Name></Call>("""\
def error(y):
    exec "a = 1"
    def f(x):
        return x + y
    return f
""")

<Call><Name>check_syntax</Name></Call>("""\
def f(x):
    def g():
        return x
    del x # can't del name
""")

<Call><Name>check_syntax</Name></Call>("""\
def f():
    def g():
         from string import *
         return strip # global or local?
""")

# and verify a few cases that should work

exec """
def noproblem1():
    from string import *
    f = lambda x:x

def noproblem2():
    from string import *
    def f(x):
        return x + 1

def noproblem3():
    from string import *
    def f(x):
        global y
        y = x
"""

print "12. lambdas"

<Name>f1</Name> = lambda <Name>x</Name>: lambda <Name>y</Name>: <Name>x</Name> + <Name>y</Name>
<Name>inc</Name> = <Call><Name>f1</Name></Call>(1)
<Name>plus10</Name> = <Call><Name>f1</Name></Call>(10)
<Call><Name>verify</Name></Call>(<Call><Name>inc</Name></Call>(1) == 2)
<Call><Name>verify</Name></Call>(<Call><Name>plus10</Name></Call>(5) == 15)

<Name>f2</Name> = lambda <Name>x</Name>: (lambda : lambda <Name>y</Name>: <Name>x</Name> + <Name>y</Name>)()
<Name>inc</Name> = <Call><Name>f2</Name></Call>(1)
<Name>plus10</Name> = <Call><Name>f2</Name></Call>(10)
<Call><Name>verify</Name></Call>(<Call><Name>inc</Name></Call>(1) == 2)
<Call><Name>verify</Name></Call>(<Call><Name>plus10</Name></Call>(5) == 15)

<Name>f3</Name> = lambda <Name>x</Name>: lambda <Name>y</Name>: <Name>global_x</Name> + <Name>y</Name>
<Name>global_x</Name> = 1
<Name>inc</Name> = <Call><Name>f3</Name></Call>(<Name>None</Name>)
<Call><Name>verify</Name></Call>(<Call><Name>inc</Name></Call>(2) == 3)

<Name>f8</Name> = lambda <Name>x</Name>, <Name>y</Name>, <Name>z</Name>: lambda <Name>a</Name>, <Name>b</Name>, <Name>c</Name>: lambda : <Name>z</Name> * (<Name>b</Name> + <Name>y</Name>)
<Name>g</Name> = <Call><Name>f8</Name></Call>(1, 2, 3)
<Name>h</Name> = <Call><Name>g</Name></Call>(2, 4, 6)
<Call><Name>verify</Name></Call>(<Call><Name>h</Name></Call>() == 18)

print "13. UnboundLocal"

def <FunctionDef>errorInOuter</FunctionDef>():
    print <Name>y</Name>
    def <FunctionDef>inner</FunctionDef>():
        return <Name>y</Name>
    <Name>y</Name> = 1

def <FunctionDef>errorInInner</FunctionDef>():
    def <FunctionDef>inner</FunctionDef>():
        return <Name>y</Name>
    <Call><Name>inner</Name></Call>()
    <Name>y</Name> = 1

try:
    <Call><Name>errorInOuter</Name></Call>()
except <Name>UnboundLocalError</Name>:
    pass
else:
    raise <Name>TestFailed</Name>

try:
    <Call><Name>errorInInner</Name></Call>()
except <Name>NameError</Name>:
    pass
else:
    raise <Name>TestFailed</Name>

print "14. complex definitions"

def <FunctionDef>makeReturner</FunctionDef>(*lst):
    def <FunctionDef>returner</FunctionDef>():
        return <Name>lst</Name>
    return <Name>returner</Name>

<Call><Name>verify</Name></Call>(<Call><Call><Name>makeReturner</Name></Call></Call>(1,2,3)() == (1,2,3))

def <FunctionDef>makeReturner2</FunctionDef>(**kwargs):
    def <FunctionDef>returner</FunctionDef>():
        return <Name>kwargs</Name>
    return <Name>returner</Name>

<Call><Name>verify</Name></Call>(<Call><Name>makeReturner2</Name></Call>(a=11)<Call>()['a'] == 11</Call>)

def <FunctionDef>makeAddPair</FunctionDef>((<Name>a</Name>, <Name>b</Name>)):
    def <FunctionDef>addPair</FunctionDef>((<Name>c</Name>, <Name>d</Name>)):
        return (<Name>a</Name> + <Name>c</Name>, <Name>b</Name> + <Name>d</Name>)
    return <Name>addPair</Name>

<Call><Name>verify</Name></Call>(<Call><Call><Name>makeAddPair</Name></Call></Call>((1, 2))((100, 200)) == (101,202))

print "15. scope of global statements"
# Examples posted by Samuele Pedroni to python-dev on 3/1/2001

# I
<Name>x</Name> = 7
def <FunctionDef>f</FunctionDef>():
    <Name>x</Name> = 1
    def <FunctionDef>g</FunctionDef>():
        global x
        def <FunctionDef>i</FunctionDef>():
            def <FunctionDef>h</FunctionDef>():
                return <Name>x</Name>
            return <Call><Name>h</Name></Call>()
        return <Call><Name>i</Name></Call>()
    return <Call><Name>g</Name></Call>()
<Call><Name>verify</Name></Call>(<Call><Name>f</Name></Call>() == 7)
<Call><Name>verify</Name></Call>(<Name>x</Name> == 7)

# II
<Name>x</Name> = 7
def <FunctionDef>f</FunctionDef>():
    <Name>x</Name> = 1
    def <FunctionDef>g</FunctionDef>():
        <Name>x</Name> = 2
        def <FunctionDef>i</FunctionDef>():
            def <FunctionDef>h</FunctionDef>():
                return <Name>x</Name>
            return <Call><Name>h</Name></Call>()
        return <Call><Name>i</Name></Call>()
    return <Call><Name>g</Name></Call>()
<Call><Name>verify</Name></Call>(<Call><Name>f</Name></Call>() == 2)
<Call><Name>verify</Name></Call>(<Name>x</Name> == 7)

# III
<Name>x</Name> = 7
def <FunctionDef>f</FunctionDef>():
    <Name>x</Name> = 1
    def <FunctionDef>g</FunctionDef>():
        global x
        <Name>x</Name> = 2
        def <FunctionDef>i</FunctionDef>():
            def <FunctionDef>h</FunctionDef>():
                return <Name>x</Name>
            return <Call><Name>h</Name></Call>()
        return <Call><Name>i</Name></Call>()
    return <Call><Name>g</Name></Call>()
<Call><Name>verify</Name></Call>(<Call><Name>f</Name></Call>() == 2)
<Call><Name>verify</Name></Call>(<Name>x</Name> == 2)

# IV
<Name>x</Name> = 7
def <FunctionDef>f</FunctionDef>():
    <Name>x</Name> = 3
    def <FunctionDef>g</FunctionDef>():
        global x
        <Name>x</Name> = 2
        def <FunctionDef>i</FunctionDef>():
            def <FunctionDef>h</FunctionDef>():
                return <Name>x</Name>
            return <Call><Name>h</Name></Call>()
        return <Call><Name>i</Name></Call>()
    return <Call><Name>g</Name></Call>()
<Call><Name>verify</Name></Call>(<Call><Name>f</Name></Call>() == 2)
<Call><Name>verify</Name></Call>(<Name>x</Name> == 2)

print "16. check leaks"

class <ClassDef>Foo</ClassDef>:
    <Name>count</Name> = 0

    def <FunctionDef>__init__</FunctionDef>(<Name>self</Name>):
        <Attribute><Name>Foo</Name></Attribute>.count += 1

    def <FunctionDef>__del__</FunctionDef>(<Name>self</Name>):
        <Attribute><Name>Foo</Name></Attribute>.count -= 1

def <FunctionDef>f1</FunctionDef>():
    <Name>x</Name> = <Call><Name>Foo</Name></Call>()
    def <FunctionDef>f2</FunctionDef>():
        return <Name>x</Name>
    <Call><Name>f2</Name></Call>()

for <Name>i</Name> in <Call><Name>range</Name></Call>(100):
    <Call><Name>f1</Name></Call>()

import os
if <Attribute><Name>os</Name></Attribute>.name == 'java':
    from java.lang import System, Thread
    <Attribute><Name>System</Name></Attribute>.<Call>gc</Call>()
    <Attribute><Name>Thread</Name></Attribute>.<Call>sleep</Call>(100)
    <Attribute><Name>System</Name></Attribute>.<Call>gc</Call>()
<Call><Name>verify</Name></Call>(<Attribute><Name>Foo</Name></Attribute>.count == 0)

print "17. class and global"

def <FunctionDef>test</FunctionDef>(<Name>x</Name>):
    class <ClassDef>Foo</ClassDef>:
        global x
        def <FunctionDef>__call__</FunctionDef>(<Name>self</Name>, <Name>y</Name>):
            return <Name>x</Name> + <Name>y</Name>
    return <Call><Name>Foo</Name></Call>()

<Name>x</Name> = 0
<Call><Name>verify</Name></Call>(<Call><Call><Name>test</Name></Call></Call>(6)(2) == 8)
<Name>x</Name> = -1
<Call><Name>verify</Name></Call>(<Call><Call><Name>test</Name></Call></Call>(3)(2) == 5)

print "18. verify that locals() works"

def <FunctionDef>f</FunctionDef>(<Name>x</Name>):
    def <FunctionDef>g</FunctionDef>(<Name>y</Name>):
        def <FunctionDef>h</FunctionDef>(<Name>z</Name>):
            return <Name>y</Name> + <Name>z</Name>
        <Name>w</Name> = <Name>x</Name> + <Name>y</Name>
        <Name>y</Name> += 3
        return <Call><Name>locals</Name></Call>()
    return <Name>g</Name>

<Name>d</Name> = <Call><Call><Name>f</Name></Call></Call>(2)(4)
<Call><Name>verify</Name></Call>(<Attribute><Name>d</Name></Attribute>.<Call>has_key</Call>('h'))
del <Name>d</Name>['h']
<Call><Name>verify</Name></Call>(<Name>d</Name> == {'x': 2, 'y': 7, 'w': 6})

print "19. var is bound and free in class"

def <FunctionDef>f</FunctionDef>(<Name>x</Name>):
    class <ClassDef>C</ClassDef>:
        def <FunctionDef>m</FunctionDef>(<Name>self</Name>):
            return <Name>x</Name>
        <Name>a</Name> = <Name>x</Name>
    return <Name>C</Name>

<Name>inst</Name> = <Call><Call><Name>f</Name></Call></Call>(3)()
<Call><Name>verify</Name></Call>(<Attribute><Name>inst</Name></Attribute>.a == <Attribute><Name>inst</Name></Attribute>.<Call>m</Call>())

print "20. interaction with trace function"

import sys
def <FunctionDef>tracer</FunctionDef>(<Name>a</Name>,<Name>b</Name>,<Name>c</Name>):
    return <Name>tracer</Name>

def <FunctionDef>adaptgetter</FunctionDef>(<Name>name</Name>, <Name>klass</Name>, <Name>getter</Name>):
    <Name>kind</Name>, <Name>des</Name> = <Name>getter</Name>
    if <Name>kind</Name> == 1:       # AV happens when stepping from this line to next
        if <Name>des</Name> == "":
            <Name>des</Name> = "_%s__%s" % (<Attribute><Name>klass</Name></Attribute>.__name__, <Name>name</Name>)
        return lambda <Name>obj</Name>: <Call><Name>getattr</Name></Call>(<Name>obj</Name>, <Name>des</Name>)

class <ClassDef>TestClass</ClassDef>:
    pass

<Attribute><Name>sys</Name></Attribute>.<Call>settrace</Call>(<Name>tracer</Name>)
<Call><Name>adaptgetter</Name></Call>("foo", <Name>TestClass</Name>, (1, ""))
<Attribute><Name>sys</Name></Attribute>.<Call>settrace</Call>(<Name>None</Name>)

try: <Attribute><Name>sys</Name></Attribute>.<Call>settrace</Call>()
except <Name>TypeError</Name>: pass
else: raise <Name>TestFailed</Name>, 'sys.settrace() did not raise TypeError'

print "20. eval and exec with free variables"

def <FunctionDef>f</FunctionDef>(<Name>x</Name>):
    return lambda: <Name>x</Name> + 1

<Name>g</Name> = <Call><Name>f</Name></Call>(3)
try:
    <Call><Name>eval</Name></Call>(<Attribute><Name>g</Name></Attribute>.func_code)
except <Name>TypeError</Name>:
    pass
else:
    print "eval() should have failed, because code contained free vars"

try:
    exec <Attribute><Name>g</Name></Attribute>.func_code
except <Name>TypeError</Name>:
    pass
else:
    print "exec should have failed, because code contained free vars"

print "21. list comprehension with local variables"

try:
    print <Name>bad</Name>
except <Name>NameError</Name>:
    pass
else:
    print "bad should not be defined"

def <FunctionDef>x</FunctionDef>():
    [<Name>bad</Name> for <Name>s</Name> in 'a b' for <Name>bad</Name> in <Attribute><Name>s</Name></Attribute>.<Call>split</Call>()]

<Call><Name>x</Name></Call>()
try:
    print <Name>bad</Name>
except <Name>NameError</Name>:
    pass

print "22. eval with free variables"

def <FunctionDef>f</FunctionDef>(<Name>x</Name>):
    def <FunctionDef>g</FunctionDef>():
        <Name>x</Name>
        <Call><Name>eval</Name></Call>("x + 1")
    return <Name>g</Name>

<Call><Call><Name>f</Name></Call></Call>(4)()
