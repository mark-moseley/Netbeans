<html><body>
NetBeans extra documentation:
Documentation for APIs missing from the RST documentation shipping with Python.
This is generated from introspecting python code using extract_rst.py.
Python version stats:
2.6 (trunk:66714:66715M, Oct  1 2008, 18:36:04) 
[GCC 4.0.1 (Apple Computer, Inc. build 5370)]

<br><br>
<a href="class:int">int</a>

<br><br>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.

<br><br>
<a href="meth:__cmp__(y)">__cmp__(y)</a>

<br><br>
   x.__cmp__(y) &lt;==> cmp(x,y)

<br><br>
<a href="meth:__coerce__(y)">__coerce__(y)</a>

<br><br>
   x.__coerce__(y) &lt;==> coerce(x, y)

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="meth:__divmod__(y)">__divmod__(y)</a>

<br><br>
   x.__divmod__(y) &lt;==> divmod(x, y)

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__float__()">__float__()</a>

<br><br>
   x.__float__() &lt;==> float(x)

<br><br>
<a href="meth:__format__()">__format__()</a>
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="meth:__getnewargs__()">__getnewargs__()</a>

<br><br>
<a href="meth:__hash__()">__hash__()</a>

<br><br>
   x.__hash__() &lt;==> hash(x)

<br><br>
<a href="meth:__hex__()">__hex__()</a>

<br><br>
   x.__hex__() &lt;==> hex(x)

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__int__()">__int__()</a>

<br><br>
   x.__int__() &lt;==> int(x)

<br><br>
<a href="meth:__long__()">__long__()</a>

<br><br>
   x.__long__() &lt;==> long(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__nonzero__()">__nonzero__()</a>

<br><br>
   x.__nonzero__() &lt;==> x != 0

<br><br>
<a href="meth:__oct__()">__oct__()</a>

<br><br>
   x.__oct__() &lt;==> oct(x)

<br><br>
<a href="meth:__radd__(y)">__radd__(y)</a>

<br><br>
   x.__radd__(y) &lt;==> y+x

<br><br>
<a href="meth:__rand__(y)">__rand__(y)</a>

<br><br>
   x.__rand__(y) &lt;==> y&amp;x

<br><br>
<a href="meth:__rdiv__(y)">__rdiv__(y)</a>

<br><br>
   x.__rdiv__(y) &lt;==> y/x

<br><br>
<a href="meth:__rdivmod__(y)">__rdivmod__(y)</a>

<br><br>
   x.__rdivmod__(y) &lt;==> divmod(y, x)

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__rfloordiv__(y)">__rfloordiv__(y)</a>

<br><br>
   x.__rfloordiv__(y) &lt;==> y//x

<br><br>
<a href="meth:__rlshift__(y)">__rlshift__(y)</a>

<br><br>
   x.__rlshift__(y) &lt;==> y&lt;&lt;x

<br><br>
<a href="meth:__rmod__(y)">__rmod__(y)</a>

<br><br>
   x.__rmod__(y) &lt;==> y%x

<br><br>
<a href="meth:__rmul__(y)">__rmul__(y)</a>

<br><br>
   x.__rmul__(y) &lt;==> y*x

<br><br>
<a href="meth:__ror__(y)">__ror__(y)</a>

<br><br>
   x.__ror__(y) &lt;==> y|x

<br><br>
<a href="meth:__rpow__(x)">__rpow__(x)</a>

<br><br>
   y.__rpow__(x[, z]) &lt;==> pow(x, y[, z])

<br><br>
<a href="meth:__rrshift__(y)">__rrshift__(y)</a>

<br><br>
   x.__rrshift__(y) &lt;==> y>>x

<br><br>
<a href="meth:__rsub__(y)">__rsub__(y)</a>

<br><br>
   x.__rsub__(y) &lt;==> y-x

<br><br>
<a href="meth:__rtruediv__(y)">__rtruediv__(y)</a>

<br><br>
   x.__rtruediv__(y) &lt;==> y/x

<br><br>
<a href="meth:__rxor__(y)">__rxor__(y)</a>

<br><br>
   x.__rxor__(y) &lt;==> y^x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   __sizeof__() -> size of object in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__trunc__()">__trunc__()</a>
   Truncating an Integral returns itself.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:conjugate()">conjugate()</a>
   Returns self, the complex conjugate of any int.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:denominator">denominator</a>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:imag">imag</a>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:numerator">numerator</a>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:real">real</a>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="class:float">float</a>
   float(x) -> floating point number

<br><br>
   Convert a string or number to a floating point number, if possible.

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   float(x) -> floating point number

<br><br>
   Convert a string or number to a floating point number, if possible.

<br><br>
<a href="meth:__coerce__(y)">__coerce__(y)</a>

<br><br>
   x.__coerce__(y) &lt;==> coerce(x, y)

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="meth:__divmod__(y)">__divmod__(y)</a>

<br><br>
   x.__divmod__(y) &lt;==> divmod(x, y)

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__float__()">__float__()</a>

<br><br>
   x.__float__() &lt;==> float(x)

<br><br>
<a href="meth:__format__(format_spec)">__format__(format_spec)</a>

<br><br>
   float.__format__(format_spec) -> string

<br><br>
   Formats the float according to format_spec.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="meth:__getformat__(typestr)">__getformat__(typestr)</a>

<br><br>
   float.__getformat__(typestr) -> string

<br><br>
   You probably don't want to use this function.  It exists mainly to be
   used in Python's test suite.

<br><br>
   typestr must be 'double' or 'float'.  This function returns whichever of
   'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the
   format of floating point numbers used by the C type named by typestr.

<br><br>
<a href="meth:__getnewargs__()">__getnewargs__()</a>

<br><br>
<a href="meth:__hash__()">__hash__()</a>

<br><br>
   x.__hash__() &lt;==> hash(x)

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__int__()">__int__()</a>

<br><br>
   x.__int__() &lt;==> int(x)

<br><br>
<a href="meth:__long__()">__long__()</a>

<br><br>
   x.__long__() &lt;==> long(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__nonzero__()">__nonzero__()</a>

<br><br>
   x.__nonzero__() &lt;==> x != 0

<br><br>
<a href="meth:__radd__(y)">__radd__(y)</a>

<br><br>
   x.__radd__(y) &lt;==> y+x

<br><br>
<a href="meth:__rdiv__(y)">__rdiv__(y)</a>

<br><br>
   x.__rdiv__(y) &lt;==> y/x

<br><br>
<a href="meth:__rdivmod__(y)">__rdivmod__(y)</a>

<br><br>
   x.__rdivmod__(y) &lt;==> divmod(y, x)

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__rfloordiv__(y)">__rfloordiv__(y)</a>

<br><br>
   x.__rfloordiv__(y) &lt;==> y//x

<br><br>
<a href="meth:__rmod__(y)">__rmod__(y)</a>

<br><br>
   x.__rmod__(y) &lt;==> y%x

<br><br>
<a href="meth:__rmul__(y)">__rmul__(y)</a>

<br><br>
   x.__rmul__(y) &lt;==> y*x

<br><br>
<a href="meth:__rpow__(x)">__rpow__(x)</a>

<br><br>
   y.__rpow__(x[, z]) &lt;==> pow(x, y[, z])

<br><br>
<a href="meth:__rsub__(y)">__rsub__(y)</a>

<br><br>
   x.__rsub__(y) &lt;==> y-x

<br><br>
<a href="meth:__rtruediv__(y)">__rtruediv__(y)</a>

<br><br>
   x.__rtruediv__(y) &lt;==> y/x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__setformat__(typestr, fmt)">__setformat__(typestr, fmt)</a>

<br><br>
   float.__setformat__(typestr, fmt) -> None

<br><br>
   You probably don't want to use this function.  It exists mainly to be
   used in Python's test suite.

<br><br>
   typestr must be 'double' or 'float'.  fmt must be one of 'unknown',
   'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be
   one of the latter two if it appears to match the underlying C reality.

<br><br>
   Overrides the automatic determination of C-level floating point type.
   This affects how floats are converted to and from binary strings.

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   __sizeof__() -> size of object in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__trunc__()">__trunc__()</a>
   Returns the Integral closest to x between 0 and x.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:conjugate()">conjugate()</a>
   Returns self, the complex conjugate of any float.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:imag">imag</a>
   float(x) -> floating point number

<br><br>
   Convert a string or number to a floating point number, if possible.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:is_integer()">is_integer()</a>
   Returns True if the float is an integer.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:real">real</a>
   float(x) -> floating point number

<br><br>
   Convert a string or number to a floating point number, if possible.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="class:long">long</a>
   long(x[, base]) -> integer

<br><br>
   Convert a string or number to a long integer, if possible.  A floating
   point argument will be truncated towards zero (this does not include a
   string representation of a floating point number!)  When converting a
   string, use the optional base.  It is an error to supply a base when
   converting a non-string.

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   long(x[, base]) -> integer

<br><br>
   Convert a string or number to a long integer, if possible.  A floating
   point argument will be truncated towards zero (this does not include a
   string representation of a floating point number!)  When converting a
   string, use the optional base.  It is an error to supply a base when
   converting a non-string.

<br><br>
<a href="meth:__cmp__(y)">__cmp__(y)</a>

<br><br>
   x.__cmp__(y) &lt;==> cmp(x,y)

<br><br>
<a href="meth:__coerce__(y)">__coerce__(y)</a>

<br><br>
   x.__coerce__(y) &lt;==> coerce(x, y)

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="meth:__divmod__(y)">__divmod__(y)</a>

<br><br>
   x.__divmod__(y) &lt;==> divmod(x, y)

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__float__()">__float__()</a>

<br><br>
   x.__float__() &lt;==> float(x)

<br><br>
<a href="meth:__format__()">__format__()</a>
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="meth:__getnewargs__()">__getnewargs__()</a>

<br><br>
<a href="meth:__hash__()">__hash__()</a>

<br><br>
   x.__hash__() &lt;==> hash(x)

<br><br>
<a href="meth:__hex__()">__hex__()</a>

<br><br>
   x.__hex__() &lt;==> hex(x)

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__int__()">__int__()</a>

<br><br>
   x.__int__() &lt;==> int(x)

<br><br>
<a href="meth:__long__()">__long__()</a>

<br><br>
   x.__long__() &lt;==> long(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__nonzero__()">__nonzero__()</a>

<br><br>
   x.__nonzero__() &lt;==> x != 0

<br><br>
<a href="meth:__oct__()">__oct__()</a>

<br><br>
   x.__oct__() &lt;==> oct(x)

<br><br>
<a href="meth:__radd__(y)">__radd__(y)</a>

<br><br>
   x.__radd__(y) &lt;==> y+x

<br><br>
<a href="meth:__rand__(y)">__rand__(y)</a>

<br><br>
   x.__rand__(y) &lt;==> y&amp;x

<br><br>
<a href="meth:__rdiv__(y)">__rdiv__(y)</a>

<br><br>
   x.__rdiv__(y) &lt;==> y/x

<br><br>
<a href="meth:__rdivmod__(y)">__rdivmod__(y)</a>

<br><br>
   x.__rdivmod__(y) &lt;==> divmod(y, x)

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__rfloordiv__(y)">__rfloordiv__(y)</a>

<br><br>
   x.__rfloordiv__(y) &lt;==> y//x

<br><br>
<a href="meth:__rlshift__(y)">__rlshift__(y)</a>

<br><br>
   x.__rlshift__(y) &lt;==> y&lt;&lt;x

<br><br>
<a href="meth:__rmod__(y)">__rmod__(y)</a>

<br><br>
   x.__rmod__(y) &lt;==> y%x

<br><br>
<a href="meth:__rmul__(y)">__rmul__(y)</a>

<br><br>
   x.__rmul__(y) &lt;==> y*x

<br><br>
<a href="meth:__ror__(y)">__ror__(y)</a>

<br><br>
   x.__ror__(y) &lt;==> y|x

<br><br>
<a href="meth:__rpow__(x)">__rpow__(x)</a>

<br><br>
   y.__rpow__(x[, z]) &lt;==> pow(x, y[, z])

<br><br>
<a href="meth:__rrshift__(y)">__rrshift__(y)</a>

<br><br>
   x.__rrshift__(y) &lt;==> y>>x

<br><br>
<a href="meth:__rsub__(y)">__rsub__(y)</a>

<br><br>
   x.__rsub__(y) &lt;==> y-x

<br><br>
<a href="meth:__rtruediv__(y)">__rtruediv__(y)</a>

<br><br>
   x.__rtruediv__(y) &lt;==> y/x

<br><br>
<a href="meth:__rxor__(y)">__rxor__(y)</a>

<br><br>
   x.__rxor__(y) &lt;==> y^x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   Returns size in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__trunc__()">__trunc__()</a>
   Truncating an Integral returns itself.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:conjugate()">conjugate()</a>
   Returns self, the complex conjugate of any long.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:denominator">denominator</a>
   long(x[, base]) -> integer

<br><br>
   Convert a string or number to a long integer, if possible.  A floating
   point argument will be truncated towards zero (this does not include a
   string representation of a floating point number!)  When converting a
   string, use the optional base.  It is an error to supply a base when
   converting a non-string.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:imag">imag</a>
   long(x[, base]) -> integer

<br><br>
   Convert a string or number to a long integer, if possible.  A floating
   point argument will be truncated towards zero (this does not include a
   string representation of a floating point number!)  When converting a
   string, use the optional base.  It is an error to supply a base when
   converting a non-string.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:numerator">numerator</a>
   long(x[, base]) -> integer

<br><br>
   Convert a string or number to a long integer, if possible.  A floating
   point argument will be truncated towards zero (this does not include a
   string representation of a floating point number!)  When converting a
   string, use the optional base.  It is an error to supply a base when
   converting a non-string.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:real">real</a>
   long(x[, base]) -> integer

<br><br>
   Convert a string or number to a long integer, if possible.  A floating
   point argument will be truncated towards zero (this does not include a
   string representation of a floating point number!)  When converting a
   string, use the optional base.  It is an error to supply a base when
   converting a non-string.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="class:bool">bool</a>
   bool(x) -> bool

<br><br>
   Returns True when the argument x is true, False otherwise.
   The builtins True and False are the only two instances of the class bool.
   The class bool is a subclass of the class int, and cannot be subclassed.

<br><br>
<a href="meth:__abs__()">__abs__()</a>

<br><br>
   x.__abs__() &lt;==> abs(x)

<br><br>
<a href="meth:__add__(y)">__add__(y)</a>

<br><br>
   x.__add__(y) &lt;==> x+y

<br><br>
<a href="meth:__and__(y)">__and__(y)</a>

<br><br>
   x.__and__(y) &lt;==> x&amp;y

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   bool(x) -> bool

<br><br>
   Returns True when the argument x is true, False otherwise.
   The builtins True and False are the only two instances of the class bool.
   The class bool is a subclass of the class int, and cannot be subclassed.

<br><br>
<a href="meth:__cmp__(y)">__cmp__(y)</a>

<br><br>
   x.__cmp__(y) &lt;==> cmp(x,y)

<br><br>
<a href="meth:__coerce__(y)">__coerce__(y)</a>

<br><br>
   x.__coerce__(y) &lt;==> coerce(x, y)

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="meth:__div__(y)">__div__(y)</a>

<br><br>
   x.__div__(y) &lt;==> x/y

<br><br>
<a href="meth:__divmod__(y)">__divmod__(y)</a>

<br><br>
   x.__divmod__(y) &lt;==> divmod(x, y)

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__float__()">__float__()</a>

<br><br>
   x.__float__() &lt;==> float(x)

<br><br>
<a href="meth:__floordiv__(y)">__floordiv__(y)</a>

<br><br>
   x.__floordiv__(y) &lt;==> x//y

<br><br>
<a href="meth:__format__()">__format__()</a>
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="meth:__getnewargs__()">__getnewargs__()</a>

<br><br>
<a href="meth:__hash__()">__hash__()</a>

<br><br>
   x.__hash__() &lt;==> hash(x)

<br><br>
<a href="meth:__hex__()">__hex__()</a>

<br><br>
   x.__hex__() &lt;==> hex(x)

<br><br>
<a href="meth:__index__()">__index__()</a>

<br><br>
   x[y:z] &lt;==> x[y.__index__():z.__index__()]

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__int__()">__int__()</a>

<br><br>
   x.__int__() &lt;==> int(x)

<br><br>
<a href="meth:__invert__()">__invert__()</a>

<br><br>
   x.__invert__() &lt;==> ~x

<br><br>
<a href="meth:__long__()">__long__()</a>

<br><br>
   x.__long__() &lt;==> long(x)

<br><br>
<a href="meth:__lshift__(y)">__lshift__(y)</a>

<br><br>
   x.__lshift__(y) &lt;==> x&lt;&lt;y

<br><br>
<a href="meth:__mod__(y)">__mod__(y)</a>

<br><br>
   x.__mod__(y) &lt;==> x%y

<br><br>
<a href="meth:__mul__(y)">__mul__(y)</a>

<br><br>
   x.__mul__(y) &lt;==> x*y

<br><br>
<a href="meth:__neg__()">__neg__()</a>

<br><br>
   x.__neg__() &lt;==> -x

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__nonzero__()">__nonzero__()</a>

<br><br>
   x.__nonzero__() &lt;==> x != 0

<br><br>
<a href="meth:__oct__()">__oct__()</a>

<br><br>
   x.__oct__() &lt;==> oct(x)

<br><br>
<a href="meth:__or__(y)">__or__(y)</a>

<br><br>
   x.__or__(y) &lt;==> x|y

<br><br>
<a href="meth:__pos__()">__pos__()</a>

<br><br>
   x.__pos__() &lt;==> +x

<br><br>
<a href="meth:__pow__(y)">__pow__(y)</a>

<br><br>
   x.__pow__(y[, z]) &lt;==> pow(x, y[, z])

<br><br>
<a href="meth:__radd__(y)">__radd__(y)</a>

<br><br>
   x.__radd__(y) &lt;==> y+x

<br><br>
<a href="meth:__rand__(y)">__rand__(y)</a>

<br><br>
   x.__rand__(y) &lt;==> y&amp;x

<br><br>
<a href="meth:__rdiv__(y)">__rdiv__(y)</a>

<br><br>
   x.__rdiv__(y) &lt;==> y/x

<br><br>
<a href="meth:__rdivmod__(y)">__rdivmod__(y)</a>

<br><br>
   x.__rdivmod__(y) &lt;==> divmod(y, x)

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__rfloordiv__(y)">__rfloordiv__(y)</a>

<br><br>
   x.__rfloordiv__(y) &lt;==> y//x

<br><br>
<a href="meth:__rlshift__(y)">__rlshift__(y)</a>

<br><br>
   x.__rlshift__(y) &lt;==> y&lt;&lt;x

<br><br>
<a href="meth:__rmod__(y)">__rmod__(y)</a>

<br><br>
   x.__rmod__(y) &lt;==> y%x

<br><br>
<a href="meth:__rmul__(y)">__rmul__(y)</a>

<br><br>
   x.__rmul__(y) &lt;==> y*x

<br><br>
<a href="meth:__ror__(y)">__ror__(y)</a>

<br><br>
   x.__ror__(y) &lt;==> y|x

<br><br>
<a href="meth:__rpow__(x)">__rpow__(x)</a>

<br><br>
   y.__rpow__(x[, z]) &lt;==> pow(x, y[, z])

<br><br>
<a href="meth:__rrshift__(y)">__rrshift__(y)</a>

<br><br>
   x.__rrshift__(y) &lt;==> y>>x

<br><br>
<a href="meth:__rshift__(y)">__rshift__(y)</a>

<br><br>
   x.__rshift__(y) &lt;==> x>>y

<br><br>
<a href="meth:__rsub__(y)">__rsub__(y)</a>

<br><br>
   x.__rsub__(y) &lt;==> y-x

<br><br>
<a href="meth:__rtruediv__(y)">__rtruediv__(y)</a>

<br><br>
   x.__rtruediv__(y) &lt;==> y/x

<br><br>
<a href="meth:__rxor__(y)">__rxor__(y)</a>

<br><br>
   x.__rxor__(y) &lt;==> y^x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   __sizeof__() -> size of object in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__sub__(y)">__sub__(y)</a>

<br><br>
   x.__sub__(y) &lt;==> x-y

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__truediv__(y)">__truediv__(y)</a>
   x.__truediv__(y) &lt;==> x/y

<br><br>
<a href="meth:__trunc__()">__trunc__()</a>

<br><br>
   Truncating an Integral returns itself.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__xor__(y)">__xor__(y)</a>
   x.__xor__(y) &lt;==> x^y

<br><br>
<a href="meth:conjugate()">conjugate()</a>

<br><br>
   Returns self, the complex conjugate of any int.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:denominator">denominator</a>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:imag">imag</a>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:numerator">numerator</a>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="attr:real">real</a>
   int(x[, base]) -> integer

<br><br>
   Convert a string or number to an integer, if possible.  A floating point
   argument will be truncated towards zero (this does not include a string
   representation of a floating point number!)  When converting a string, use
   the optional base.  It is an error to supply a base when converting a
   non-string.  If base is zero, the proper base is guessed based on the
   string content.  If the argument is outside the integer range a
   long object will be returned instead.
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="class:complex">complex</a>
   complex(real[, imag]) -> complex number

<br><br>
   Create a complex number from a real part and an optional imaginary part.
   This is equivalent to (real + imag*1j) where imag defaults to 0.

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   complex(real[, imag]) -> complex number

<br><br>
   Create a complex number from a real part and an optional imaginary part.
   This is equivalent to (real + imag*1j) where imag defaults to 0.

<br><br>
<a href="meth:__coerce__(y)">__coerce__(y)</a>

<br><br>
   x.__coerce__(y) &lt;==> coerce(x, y)

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="meth:__divmod__(y)">__divmod__(y)</a>

<br><br>
   x.__divmod__(y) &lt;==> divmod(x, y)

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__float__()">__float__()</a>

<br><br>
   x.__float__() &lt;==> float(x)

<br><br>
<a href="meth:__format__()">__format__()</a>

<br><br>
   default object formatter
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="meth:__getnewargs__()">__getnewargs__()</a>

<br><br>
<a href="meth:__hash__()">__hash__()</a>

<br><br>
   x.__hash__() &lt;==> hash(x)

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__int__()">__int__()</a>

<br><br>
   x.__int__() &lt;==> int(x)

<br><br>
<a href="meth:__long__()">__long__()</a>

<br><br>
   x.__long__() &lt;==> long(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__nonzero__()">__nonzero__()</a>

<br><br>
   x.__nonzero__() &lt;==> x != 0

<br><br>
<a href="meth:__radd__(y)">__radd__(y)</a>

<br><br>
   x.__radd__(y) &lt;==> y+x

<br><br>
<a href="meth:__rdiv__(y)">__rdiv__(y)</a>

<br><br>
   x.__rdiv__(y) &lt;==> y/x

<br><br>
<a href="meth:__rdivmod__(y)">__rdivmod__(y)</a>

<br><br>
   x.__rdivmod__(y) &lt;==> divmod(y, x)

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__rfloordiv__(y)">__rfloordiv__(y)</a>

<br><br>
   x.__rfloordiv__(y) &lt;==> y//x

<br><br>
<a href="meth:__rmod__(y)">__rmod__(y)</a>

<br><br>
   x.__rmod__(y) &lt;==> y%x

<br><br>
<a href="meth:__rmul__(y)">__rmul__(y)</a>

<br><br>
   x.__rmul__(y) &lt;==> y*x

<br><br>
<a href="meth:__rpow__(x)">__rpow__(x)</a>

<br><br>
   y.__rpow__(x[, z]) &lt;==> pow(x, y[, z])

<br><br>
<a href="meth:__rsub__(y)">__rsub__(y)</a>

<br><br>
   x.__rsub__(y) &lt;==> y-x

<br><br>
<a href="meth:__rtruediv__(y)">__rtruediv__(y)</a>

<br><br>
   x.__rtruediv__(y) &lt;==> y/x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   __sizeof__() -> size of object in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:conjugate()">conjugate()</a>
   complex.conjugate() -> complex

<br><br>
   Returns the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.

<br><br>
<a href="attr:imag">imag</a>

<br><br>
   float(x) -> floating point number

<br><br>
   Convert a string or number to a floating point number, if possible.

<br><br>
<a href="attr:real">real</a>

<br><br>
   float(x) -> floating point number

<br><br>
   Convert a string or number to a floating point number, if possible.

<br><br>
<a href="class:list">list</a>

<br><br>
   list() -> new list
   list(sequence) -> new list initialized from sequence's items

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   list() -> new list
   list(sequence) -> new list initialized from sequence's items

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__format__()">__format__()</a>

<br><br>
   default object formatter
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="attr:__hash__">__hash__</a>

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__iter__()">__iter__()</a>

<br><br>
   x.__iter__() &lt;==> iter(x)

<br><br>
<a href="meth:__len__()">__len__()</a>

<br><br>
   x.__len__() &lt;==> len(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__reversed__()">__reversed__()</a>

<br><br>
   L.__reversed__() -- return a reverse iterator over the list

<br><br>
<a href="meth:__rmul__(n)">__rmul__(n)</a>

<br><br>
   x.__rmul__(n) &lt;==> n*x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   L.__sizeof__() -- size of L in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:append()">append()</a>
   L.append(object) -- append object to end

<br><br>
<a href="meth:count(value)">count(value)</a>

<br><br>
   L.count(value) -> integer -- return number of occurrences of value

<br><br>
<a href="meth:extend()">extend()</a>

<br><br>
   L.extend(iterable) -- extend list by appending elements from the iterable

<br><br>
<a href="meth:insert()">insert()</a>

<br><br>
   L.insert(index, object) -- insert object before index

<br><br>
<a href="meth:pop()">pop()</a>

<br><br>
   L.pop([index]) -> item -- remove and return item at index (default last)

<br><br>
<a href="meth:remove()">remove()</a>

<br><br>
   L.remove(value) -- remove first occurrence of value

<br><br>
<a href="meth:reverse()">reverse()</a>

<br><br>
   L.reverse() -- reverse *IN PLACE*

<br><br>
<a href="meth:sort(cmp=None, key=None, reverse=False) __ stable sort *IN PLACE*;">sort(cmp=None, key=None, reverse=False) __ stable sort *IN PLACE*;</a>
cmp(x, y)

<br><br>
   L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;
   cmp(x, y) -> -1, 0, 1

<br><br>
<a href="class:dict">dict</a>

<br><br>
   dict() -> new empty dictionary.
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs.
   dict(seq) -> new dictionary initialized as if via:
       d = {}
       for k, v in seq:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   dict() -> new empty dictionary.
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs.
   dict(seq) -> new dictionary initialized as if via:
       d = {}
       for k, v in seq:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)

<br><br>
<a href="meth:__cmp__(y)">__cmp__(y)</a>

<br><br>
   x.__cmp__(y) &lt;==> cmp(x,y)

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__format__()">__format__()</a>

<br><br>
   default object formatter
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="attr:__hash__">__hash__</a>

<br><br>
<a href="meth:__iter__()">__iter__()</a>

<br><br>
   x.__iter__() &lt;==> iter(x)

<br><br>
<a href="meth:__len__()">__len__()</a>

<br><br>
   x.__len__() &lt;==> len(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   D.__sizeof__() -> size of D in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="class:tuple">tuple</a>
   tuple() -> an empty tuple
   tuple(sequence) -> tuple initialized from sequence's items

<br><br>
   If the argument is a tuple, the return value is the same object.

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   tuple() -> an empty tuple
   tuple(sequence) -> tuple initialized from sequence's items

<br><br>
   If the argument is a tuple, the return value is the same object.

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__format__()">__format__()</a>

<br><br>
   default object formatter
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="meth:__getnewargs__()">__getnewargs__()</a>

<br><br>
<a href="meth:__hash__()">__hash__()</a>

<br><br>
   x.__hash__() &lt;==> hash(x)

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__iter__()">__iter__()</a>

<br><br>
   x.__iter__() &lt;==> iter(x)

<br><br>
<a href="meth:__len__()">__len__()</a>

<br><br>
   x.__len__() &lt;==> len(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__rmul__(n)">__rmul__(n)</a>

<br><br>
   x.__rmul__(n) &lt;==> n*x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   T.__sizeof__() -- size of T in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:count(value)">count(value)</a>
   T.count(value) -> integer -- return number of occurrences of value
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="class:str">str</a>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__format__(format_spec)">__format__(format_spec)</a>

<br><br>
   S.__format__(format_spec) -> unicode
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="meth:__getnewargs__()">__getnewargs__()</a>

<br><br>
<a href="meth:__hash__()">__hash__()</a>

<br><br>
   x.__hash__() &lt;==> hash(x)

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__len__()">__len__()</a>

<br><br>
   x.__len__() &lt;==> len(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__rmod__(y)">__rmod__(y)</a>

<br><br>
   x.__rmod__(y) &lt;==> y%x

<br><br>
<a href="meth:__rmul__(n)">__rmul__(n)</a>

<br><br>
   x.__rmul__(n) &lt;==> n*x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   S.__sizeof__() -> size of S in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:_formatter_field_name_split()">_formatter_field_name_split()</a>
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:_formatter_parser()">_formatter_parser()</a>
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="class:unicode">unicode</a>
   unicode(string [, encoding[, errors]]) -> object

<br><br>
   Create a new Unicode object from the given encoded string.
   encoding defaults to the current default string encoding.
   errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.

<br><br>
<a href="attr:__class__">__class__</a>

<br><br>
   unicode(string [, encoding[, errors]]) -> object

<br><br>
   Create a new Unicode object from the given encoded string.
   encoding defaults to the current default string encoding.
   errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.

<br><br>
<a href="meth:__delattr__(name)">__delattr__(name)</a>

<br><br>
   x.__delattr__('name') &lt;==> del x.name

<br><br>
<a href="attr:__doc__">__doc__</a>

<br><br>
   str(object) -> string

<br><br>
   Return a nice string representation of the object.
   If the argument is a string, the return value is the same object.

<br><br>
<a href="meth:__format__(format_spec)">__format__(format_spec)</a>

<br><br>
   S.__format__(format_spec) -> unicode
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__getattribute__(name)">__getattribute__(name)</a>
   x.__getattribute__('name') &lt;==> x.name

<br><br>
<a href="meth:__getnewargs__()">__getnewargs__()</a>

<br><br>
<a href="meth:__hash__()">__hash__()</a>

<br><br>
   x.__hash__() &lt;==> hash(x)

<br><br>
<a href="meth:__init__()">__init__()</a>

<br><br>
   x.__init__(...) initializes x; see x.__class__.__doc__ for signature

<br><br>
<a href="meth:__len__()">__len__()</a>

<br><br>
   x.__len__() &lt;==> len(x)

<br><br>
<a href="meth:__new__(S, ___)">__new__(S, ___)</a>

<br><br>
   T.__new__(S, ...) -> a new object with type S, a subtype of T

<br><br>
<a href="meth:__reduce__()">__reduce__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__reduce_ex__()">__reduce_ex__()</a>

<br><br>
   helper for pickle

<br><br>
<a href="meth:__repr__()">__repr__()</a>

<br><br>
   x.__repr__() &lt;==> repr(x)

<br><br>
<a href="meth:__rmod__(y)">__rmod__(y)</a>

<br><br>
   x.__rmod__(y) &lt;==> y%x

<br><br>
<a href="meth:__rmul__(n)">__rmul__(n)</a>

<br><br>
   x.__rmul__(n) &lt;==> n*x

<br><br>
<a href="meth:__setattr__(name, value)">__setattr__(name, value)</a>

<br><br>
   x.__setattr__('name', value) &lt;==> x.name = value

<br><br>
<a href="meth:__sizeof__()">__sizeof__()</a>

<br><br>
   S.__sizeof__() -> size of S in memory, in bytes
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:__str__()">__str__()</a>
   x.__str__() &lt;==> str(x)

<br><br>
<a href="meth:__subclasshook__()">__subclasshook__()</a>

<br><br>
   Abstract classes can override this to customize issubclass().

<br><br>
   This is invoked early on by abc.ABCMeta.__subclasscheck__().
   It should return True, False or NotImplemented.  If it returns
   NotImplemented, the normal algorithm is used.  Otherwise, it
   overrides the normal algorithm (and the outcome is cached).
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:_formatter_field_name_split()">_formatter_field_name_split()</a>
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:_formatter_parser()">_formatter_parser()</a>
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:capitalize()">capitalize()</a>
   S.capitalize() -> unicode

<br><br>
   Return a capitalized version of S, i.e. make the first character
   have upper case.

<br><br>
<a href="meth:center(width)">center(width)</a>

<br><br>
   S.center(width[, fillchar]) -> unicode

<br><br>
   Return S centered in a Unicode string of length width. Padding is
   done using the specified fill character (default is a space)

<br><br>
<a href="meth:count(sub)">count(sub)</a>

<br><br>
   S.count(sub[, start[, end]]) -> int

<br><br>
   Return the number of non-overlapping occurrences of substring sub in
   Unicode string S[start:end].  Optional arguments start and end are
   interpreted as in slice notation.

<br><br>
<a href="meth:decode()">decode()</a>

<br><br>
   S.decode([encoding[,errors]]) -> string or unicode

<br><br>
   Decodes S using the codec registered for encoding. encoding defaults
   to the default encoding. errors may be given to set a different error
   handling scheme. Default is 'strict' meaning that encoding errors raise
   a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
   as well as any other name registerd with codecs.register_error that is
   able to handle UnicodeDecodeErrors.

<br><br>
<a href="meth:encode()">encode()</a>

<br><br>
   S.encode([encoding[,errors]]) -> string or unicode

<br><br>
   Encodes S using the codec registered for encoding. encoding defaults
   to the default encoding. errors may be given to set a different error
   handling scheme. Default is 'strict' meaning that encoding errors raise
   a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
   'xmlcharrefreplace' as well as any other name registered with
   codecs.register_error that can handle UnicodeEncodeErrors.

<br><br>
<a href="meth:endswith(suffix)">endswith(suffix)</a>

<br><br>
   S.endswith(suffix[, start[, end]]) -> bool

<br><br>
   Return True if S ends with the specified suffix, False otherwise.
   With optional start, test S beginning at that position.
   With optional end, stop comparing S at that position.
   suffix can also be a tuple of strings to try.

<br><br>
<a href="meth:expandtabs()">expandtabs()</a>

<br><br>
   S.expandtabs([tabsize]) -> unicode

<br><br>
   Return a copy of S where all tab characters are expanded using spaces.
   If tabsize is not given, a tab size of 8 characters is assumed.

<br><br>
<a href="meth:find(sub )">find(sub )</a>

<br><br>
   S.find(sub [,start [,end]]) -> int

<br><br>
   Return the lowest index in S where substring sub is found,
   such that sub is contained within s[start:end].  Optional
   arguments start and end are interpreted as in slice notation.

<br><br>
   Return -1 on failure.

<br><br>
<a href="meth:format(*args, **kwargs)">format(*args, **kwargs)</a>

<br><br>
   S.format(*args, **kwargs) -> unicode
<div style="margin: 5px 5px; background: #dddddd; border-size: 1px; padding: 5px"><b>Version Added</b>:  2.6
</div>
<a href="meth:isalnum()">isalnum()</a>
   S.isalnum() -> bool

<br><br>
   Return True if all characters in S are alphanumeric
   and there is at least one character in S, False otherwise.

<br><br>
<a href="meth:isalpha()">isalpha()</a>

<br><br>
   S.isalpha() -> bool

<br><br>
   Return True if all characters in S are alphabetic
   and there is at least one character in S, False otherwise.

<br><br>
<a href="meth:isdigit()">isdigit()</a>

<br><br>
   S.isdigit() -> bool

<br><br>
   Return True if all characters in S are digits
   and there is at least one character in S, False otherwise.

<br><br>
<a href="meth:islower()">islower()</a>

<br><br>
   S.islower() -> bool

<br><br>
   Return True if all cased characters in S are lowercase and there is
   at least one cased character in S, False otherwise.

<br><br>
<a href="meth:isspace()">isspace()</a>

<br><br>
   S.isspace() -> bool

<br><br>
   Return True if all characters in S are whitespace
   and there is at least one character in S, False otherwise.

<br><br>
<a href="meth:istitle()">istitle()</a>

<br><br>
   S.istitle() -> bool

<br><br>
   Return True if S is a titlecased string and there is at least one
   character in S, i.e. upper- and titlecase characters may only
   follow uncased characters and lowercase characters only cased ones.
   Return False otherwise.

<br><br>
<a href="meth:isupper()">isupper()</a>

<br><br>
   S.isupper() -> bool

<br><br>
   Return True if all cased characters in S are uppercase and there is
   at least one cased character in S, False otherwise.

<br><br>
<a href="meth:join(sequence)">join(sequence)</a>

<br><br>
   S.join(sequence) -> unicode

<br><br>
   Return a string which is the concatenation of the strings in the
   sequence.  The separator between elements is S.

<br><br>
<a href="meth:ljust(width)">ljust(width)</a>

<br><br>
   S.ljust(width[, fillchar]) -> int

<br><br>
   Return S left justified in a Unicode string of length width. Padding is
   done using the specified fill character (default is a space).

<br><br>
<a href="meth:lower()">lower()</a>

<br><br>
   S.lower() -> unicode

<br><br>
   Return a copy of the string S converted to lowercase.

<br><br>
<a href="meth:lstrip()">lstrip()</a>

<br><br>
   S.lstrip([chars]) -> unicode

<br><br>
   Return a copy of the string S with leading whitespace removed.
   If chars is given and not None, remove characters in chars instead.
   If chars is a str, it will be converted to unicode before stripping

<br><br>
<a href="meth:partition(sep)">partition(sep)</a>

<br><br>
   S.partition(sep) -> (head, sep, tail)

<br><br>
   Searches for the separator sep in S, and returns the part before it,
   the separator itself, and the part after it.  If the separator is not
   found, returns S and two empty strings.

<br><br>
<a href="meth:replace(old, new)">replace(old, new)</a>

<br><br>
   S.replace (old, new[, count]) -> unicode

<br><br>
   Return a copy of S with all occurrences of substring
   old replaced by new.  If the optional argument count is
   given, only the first count occurrences are replaced.

<br><br>
<a href="meth:rfind(sub )">rfind(sub )</a>

<br><br>
   S.rfind(sub [,start [,end]]) -> int

<br><br>
   Return the highest index in S where substring sub is found,
   such that sub is contained within s[start:end].  Optional
   arguments start and end are interpreted as in slice notation.

<br><br>
   Return -1 on failure.

<br><br>
<a href="meth:rindex(sub )">rindex(sub )</a>

<br><br>
   S.rindex(sub [,start [,end]]) -> int

<br><br>
   Like S.rfind() but raise ValueError when the substring is not found.

<br><br>
<a href="meth:rjust(width)">rjust(width)</a>

<br><br>
   S.rjust(width[, fillchar]) -> unicode

<br><br>
   Return S right justified in a Unicode string of length width. Padding is
   done using the specified fill character (default is a space).

<br><br>
<a href="meth:rpartition(sep)">rpartition(sep)</a>

<br><br>
   S.rpartition(sep) -> (tail, sep, head)

<br><br>
   Searches for the separator sep in S, starting at the end of S, and returns
   the part before it, the separator itself, and the part after it.  If the
   separator is not found, returns two empty strings and S.

<br><br>
<a href="meth:rsplit()">rsplit()</a>

<br><br>
   S.rsplit([sep [,maxsplit]]) -> list of strings

<br><br>
   Return a list of the words in S, using sep as the
   delimiter string, starting at the end of the string and
   working to the front.  If maxsplit is given, at most maxsplit
   splits are done. If sep is not specified, any whitespace string
   is a separator.

<br><br>
<a href="meth:rstrip()">rstrip()</a>

<br><br>
   S.rstrip([chars]) -> unicode

<br><br>
   Return a copy of the string S with trailing whitespace removed.
   If chars is given and not None, remove characters in chars instead.
   If chars is a str, it will be converted to unicode before stripping

<br><br>
<a href="meth:split()">split()</a>

<br><br>
   S.split([sep [,maxsplit]]) -> list of strings

<br><br>
   Return a list of the words in S, using sep as the
   delimiter string.  If maxsplit is given, at most maxsplit
   splits are done. If sep is not specified or is None, any
   whitespace string is a separator and empty strings are
   removed from the result.

<br><br>
<a href="meth:splitlines()">splitlines()</a>

<br><br>
   S.splitlines([keepends]]) -> list of strings

<br><br>
   Return a list of the lines in S, breaking at line boundaries.
   Line breaks are not included in the resulting list unless keepends
   is given and true.

<br><br>
<a href="meth:startswith(prefix)">startswith(prefix)</a>

<br><br>
   S.startswith(prefix[, start[, end]]) -> bool

<br><br>
   Return True if S starts with the specified prefix, False otherwise.
   With optional start, test S beginning at that position.
   With optional end, stop comparing S at that position.
   prefix can also be a tuple of strings to try.

<br><br>
<a href="meth:strip()">strip()</a>

<br><br>
   S.strip([chars]) -> unicode

<br><br>
   Return a copy of the string S with leading and trailing
   whitespace removed.
   If chars is given and not None, remove characters in chars instead.
   If chars is a str, it will be converted to unicode before stripping

<br><br>
<a href="meth:swapcase()">swapcase()</a>

<br><br>
   S.swapcase() -> unicode

<br><br>
   Return a copy of S with uppercase characters converted to lowercase
   and vice versa.

<br><br>
<a href="meth:title()">title()</a>

<br><br>
   S.title() -> unicode

<br><br>
   Return a titlecased version of S, i.e. words start with title case
   characters, all remaining cased characters have lower case.

<br><br>
<a href="meth:translate(table)">translate(table)</a>

<br><br>
   S.translate(table) -> unicode

<br><br>
   Return a copy of the string S, where all characters have been mapped
   through the given translation table, which must be a mapping of
   Unicode ordinals to Unicode ordinals, Unicode strings or None.
   Unmapped characters are left untouched. Characters mapped to None
   are deleted.

<br><br>
<a href="meth:upper()">upper()</a>

<br><br>
   S.upper() -> unicode

<br><br>
   Return a copy of S converted to uppercase.

<br><br>
<a href="meth:zfill(width)">zfill(width)</a>

<br><br>
   S.zfill(width) -> unicode

<br><br>
   Pad a numeric string S with zeros on the left, to fill a field
   of the specified width. The string S is never truncated.
</body></html>
