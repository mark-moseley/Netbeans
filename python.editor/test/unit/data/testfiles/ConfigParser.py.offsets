
<Module><Expr><Str>"""Configuration file parser.

A setup file consists of sections, lead by a "[section]" header,
and followed by "name: value" entries, with continuations and such in
the style of RFC 822.

 the same section, or values in a special [DEFAULT] section.

For example:

    something: %(dir)s/whatever

would resolve the "%(dir)s" to the value of dir.  All reference
expansions are done late, on demand.

Intrinsic defaults can be specified by passing them into the
ConfigParser constructor as a dictionary.

class:

ConfigParser -- responsible for parsing a list of
                configuration files, and managing the parsed database.

    methods:

    __init__(defaults=None)
        create the parser and specify a dictionary of intrinsic defaults.  The
        keys must be strings, the values must be appropriate for %()s string
        interpolation.  Note that `__name__' is always an intrinsic default;
        it's value is the section's name.

    sections()
        return all the configuration section names, sans DEFAULT

    has_section(section)
        return whether the given section exists

    has_option(section, option)
        return whether the given option exists in the given section

    options(section)
        return list of configuration options for the named section

    read(filenames)
        read and parse the list of named configuration files, given by
        name.  A single filename is also allowed.  Non-existing files
        are ignored.

    readfp(fp, filename=None)
        read and parse one configuration file, given as a file object.
        The filename defaults to fp.name; it is only used in error
        messages (if fp has no `name' attribute, the string `&lt;???&gt;' is used).

    get(section, option, raw=False, vars=None)
        return a string value for the named option.  All % interpolations are
        expanded in the return values, based on the defaults passed into the
        constructor and the DEFAULT section.  Additional substitutions may be
        provided using the `vars' argument, which must be a dictionary whose
        contents override any pre-existing defaults.

    getint(section, options)
        like get(), but convert value to an integer

    getfloat(section, options)
        like get(), but convert value to a float

    getboolean(section, options)
        like get(), but convert value to a boolean (currently case
        insensitively defined as 0, false, no, off for False, and 1, true,
        yes, on for True).  Returns False or True.

    items(section, raw=False, vars=None)
        return a list of tuples with (name, value) for each option
        in the section.

    remove_section(section)
        remove the given file section and all its options

    remove_option(section, option)
        remove the given option from the given section

    set(section, option, value)
        set the given option

    write(fp)
        write the configuration state in .ini format
"""</Str></Expr>

<Import>import re</Import>

<Assign><Name>__all__</Name> = <List>[<Str>"NoSectionError"</Str>, <Str>"DuplicateSectionError"</Str>, <Str>"NoOptionError"</Str>,
           <Str>"InterpolationError"</Str>, <Str>"InterpolationDepthError"</Str>,
           <Str>"InterpolationSyntaxError"</Str>, <Str>"ParsingError"</Str>,
           <Str>"MissingSectionHeaderError"</Str>, <Str>"ConfigParser"</Str>, <Str>"SafeConfigParser"</Str>,
           <Str>"DEFAULTSECT"</Str>, <Str>"MAX_INTERPOLATION_DEPTH"</Str>]</List></Assign>

<Assign><Name>DEFAULTSECT</Name> = <Str>"DEFAULT"</Str></Assign>

<Assign><Name>MAX_INTERPOLATION_DEPTH</Name> = <Num>10</Num></Assign>



# exception classes
<ClassDef>class Error(<Name>Exception</Name>):
    <Expr><Str>"""Base class for ConfigParser exceptions."""</Str></Expr>

    <FunctionDef>def __init__(<Name>self</Name>, <Name>msg</Name>=<Str>''</Str>):
        <Assign><Attribute><Name>self</Name>.message</Attribute> = <Name>msg</Name></Assign>
        <Expr><Call><Attribute><Name>Exception</Name>.__init__</Attribute>(<Name>self</Name>, <Name>msg</Name>)</Call></Expr>

   </FunctionDef> <FunctionDef>def __repr__(<Name>self</Name>):
        <Return>return <Attribute><Name>self</Name>.message</Attribute></Return>

   </FunctionDef> <Assign><Name>__str__</Name> = <Name>__repr__</Name></Assign>

</ClassDef><ClassDef>class NoSectionError(<Name>Error</Name>):
    <Expr><Str>"""Rasssised when no section matches a requested option."""</Str></Expr>
 
    <FunctionDef>def __init__(<Name>self</Name>, <Name>section</Name>):
        <Expr><Call><Attribute><Name>Error</Name>.__init__</Attribute>(<Name>self</Name>, <BinOp><Str>'No section: '</Str> + <Repr>`<Name>section</Name>`</Repr></BinOp>)</Call></Expr>
        <Assign><Attribute><Name>self</Name>.section</Attribute> = <Name>section</Name></Assign>

</FunctionDef></ClassDef><ClassDef>class DuplicateSectionError(<Name>Error</Name>):
    <Expr><Str>"""Raised when a section is multiply-created."""</Str></Expr>

    <FunctionDef>def __init__(<Name>self</Name>, <Name>section</Name>):
        <Expr><Call><Attribute><Name>Error</Name>.__init__</Attribute>(<Name>self</Name>, <BinOp><Str>"Section %r already exists"</Str> % <Name>section</Name></BinOp>)</Call></Expr>
        <Assign><Attribute><Name>self</Name>.section</Attribute> = <Name>section</Name></Assign>

</FunctionDef></ClassDef><ClassDef>class NoOptionError(<Name>Error</Name>):
    <Expr><Str>"""A requested option was not found."""</Str></Expr>

    <FunctionDef>def __init__(<Name>self</Name>, <Name>option</Name>, <Name>section</Name>):
        <Expr><Call><Attribute><Name>Error</Name>.__init__</Attribute>(<Name>self</Name>, <BinOp><Str>"No option %r in section: %r"</Str> %
                       <Tuple>(<Name>option</Name>, <Name>section</Name>)</Tuple></BinOp>)</Call></Expr>
        <Assign><Attribute><Name>self</Name>.option</Attribute> = <Name>option</Name></Assign>
        <Assign><Attribute><Name>self</Name>.section</Attribute> = <Name>section</Name></Assign>

</FunctionDef></ClassDef><ClassDef>class InterpolationError(<Name>Error</Name>):
    <Expr><Str>"""Base class for interpolation-related exceptions."""</Str></Expr>

    <FunctionDef>def __init__(<Name>self</Name>, <Name>option</Name>, <Name>section</Name>, <Name>msg</Name>):
        <Expr><Call><Attribute><Name>Error</Name>.__init__</Attribute>(<Name>self</Name>, <Name>msg</Name>)</Call></Expr>
        <Assign><Attribute><Name>self</Name>.option</Attribute> = <Name>option</Name></Assign>
        <Assign><Attribute><Name>self</Name>.section</Attribute> = <Name>section</Name></Assign>

</FunctionDef></ClassDef><ClassDef>class InterpolationMissingOptionError(<Name>InterpolationError</Name>):
    <Expr><Str>"""A string substitution required a setting which was not available."""</Str></Expr>

    <FunctionDef>def __init__(<Name>self</Name>, <Name>option</Name>, <Name>section</Name>, <Name>rawval</Name>, <Name>reference</Name>):
        <Assign><Name>msg</Name> = <BinOp>(<Str>"Bad value substitution:\n"
               "\tsection: [%s]\n"
               "\toption : %s\n"
               "\tkey    : %s\n"
               "\trawval : %s\n"</Str>
               % <Tuple>(<Name>section</Name>, <Name>option</Name>, <Name>reference</Name>, <Name>rawval</Name>)</Tuple>)</BinOp></Assign>
        <Expr><Call><Attribute><Name>InterpolationError</Name>.__init__</Attribute>(<Name>self</Name>, <Name>option</Name>, <Name>section</Name>, <Name>msg</Name>)</Call></Expr>
        <Assign><Attribute><Name>self</Name>.reference</Attribute> = <Name>reference</Name></Assign>

</FunctionDef></ClassDef><ClassDef>class InterpolationSyntaxError(<Name>InterpolationError</Name>):
    <Expr><Str>"""Raised when the source text into which substitutions are made
    does not conform to the required syntax."""</Str></Expr>

</ClassDef><ClassDef>class InterpolationDepthError(<Name>InterpolationError</Name>):
    <Expr><Str>"""Raised when substitutions are nested too deeply."""</Str></Expr>

    <FunctionDef>def __init__(<Name>self</Name>, <Name>option</Name>, <Name>section</Name>, <Name>rawval</Name>):
        <Assign><Name>msg</Name> = <BinOp>(<Str>"Value interpolation too deeply recursive:\n"
               "\tsection: [%s]\n"
               "\toption : %s\n"
               "\trawval : %s\n"</Str>
               % <Tuple>(<Name>section</Name>, <Name>option</Name>, <Name>rawval</Name>)</Tuple>)</BinOp></Assign>
        <Expr><Call><Attribute><Name>InterpolationError</Name>.__init__</Attribute>(<Name>self</Name>, <Name>option</Name>, <Name>section</Name>, <Name>msg</Name>)</Call></Expr>

</FunctionDef></ClassDef><ClassDef>class ParsingError(<Name>Error</Name>):
    <Expr><Str>"""Raised when a configuration file does not follow legal syntax."""</Str></Expr>

    <FunctionDef>def __init__(<Name>self</Name>, <Name>filename</Name>):
        <Expr><Call><Attribute><Name>Error</Name>.__init__</Attribute>(<Name>self</Name>, <BinOp><Str>'File contains parsing errors: %s'</Str> % <Name>filename</Name></BinOp>)</Call></Expr>
        <Assign><Attribute><Name>self</Name>.filename</Attribute> = <Name>filename</Name></Assign> 
        <Assign><Attribute><Name>self</Name>.errors</Attribute> = <List>[]</List></Assign>

   </FunctionDef> <FunctionDef>def append(<Name>self</Name>, <Name>lineno</Name>, <Name>line</Name>):
        <Expr><Call><Attribute><Attribute><Name>self</Name>.errors</Attribute>.append</Attribute>(<Tuple>(<Name>lineno</Name>, <Name>line</Name>)</Tuple>)</Call></Expr>
        <AugAssign><Attribute><Name>self</Name>.message</Attribute> += <BinOp><Str>'\n\t[line %2d]: %s'</Str> % <Tuple>(<Name>lineno</Name>, <Name>line</Name>)</Tuple></BinOp></AugAssign>

</FunctionDef></ClassDef><ClassDef>class MissingSectionHeaderError(<Name>ParsingError</Name>):
    <Expr><Str>"""Raised when a key-value pair is found before any section header."""</Str></Expr>

    <FunctionDef>def __init__(<Name>self</Name>, <Name>filename</Name>, <Name>lineno</Name>, <Name>line</Name>):
        <Expr><Call><Attribute><Name>Error</Name>.__init__</Attribute>(
            <Name>self</Name>,
            <BinOp><Str>'File contains no section headers.\nfile: %s, line: %d\n%s'</Str> %
            <Tuple>(<Name>filename</Name>, <Name>lineno</Name>, <Name>line</Name>)</Tuple></BinOp>)</Call></Expr>
        <Assign><Attribute><Name>self</Name>.filename</Attribute> = <Name>filename</Name></Assign>
        <Assign><Attribute><Name>self</Name>.lineno</Attribute> = <Name>lineno</Name></Assign>
        <Assign><Attribute><Name>self</Name>.line</Attribute> = <Name>line</Name></Assign>



</FunctionDef></ClassDef><ClassDef>class RawConfigParser:
    <FunctionDef>def __init__(<Name>self</Name>, <Name>defaults</Name>=<Name>None</Name>):
        <Assign><Attribute><Name>self</Name>._sections</Attribute> = <Dict>{}</Dict></Assign>
        <If>if <Compare><Name>defaults</Name> is <Name>None</Name></Compare>:
            <Assign><Attribute><Name>self</Name>._defaults</Attribute> = <Dict>{}</Dict></Assign>
        else:
            <Assign><Attribute><Name>self</Name>._defaults</Attribute> = <Name>defaults</Name></Assign>

   </If></FunctionDef> <FunctionDef>def defaults(<Name>self</Name>):
        <Return>return <Attribute><Name>self</Name>._defaults</Attribute></Return>

   </FunctionDef> <FunctionDef>def sections(<Name>self</Name>):
        <Expr><Str>"""Return a list of section names, excluding [DEFAULT]"""</Str></Expr>
        # self._sections will never have [DEFAULT] in it
        <Return>return <Call><Attribute><Attribute><Name>self</Name>._sections</Attribute>.keys</Attribute>()</Call></Return>

   </FunctionDef> <FunctionDef>def add_section(<Name>self</Name>, <Name>section</Name>):
        <Expr><Str>"""Create a new section in the configuration.

        Raise DuplicateSectionError if a section by the specified name
        already exists.
        """</Str></Expr>
        <If>if <Compare><Name>section</Name> in <Attribute><Name>self</Name>._sections</Attribute></Compare>:
            <Raise>raise <Call><Name>DuplicateSectionError</Name>(<Name>section</Name>)</Call></Raise>
       </If> <Assign><Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript> = <Dict>{}</Dict></Assign>

   </FunctionDef> <FunctionDef>def has_section(<Name>self</Name>, <Name>section</Name>):
        <Expr><Str>"""Indicate whether the named section is present in the configuration.

        The DEFAULT section is not acknowledged.
        """</Str></Expr>
        <Return>return <Compare><Name>section</Name> in <Attribute><Name>self</Name>._sections</Attribute></Compare></Return>

   </FunctionDef> <FunctionDef>def options(<Name>self</Name>, <Name>section</Name>):
        <Expr><Str>"""Return a list of option names for the given section name."""</Str></Expr>
        <TryExcept>try:
            <Assign><Name>opts</Name> = <Call><Attribute><Name>self</Name>._sections</Attribute><Attribute><Subscript>[<Index><Name>section</Name></Index>]</Subscript>.copy</Attribute>()</Call></Assign>
        <ExceptHandler>except <Name>KeyError</Name>:
            <Raise>raise <Call><Name>NoSectionError</Name>(<Name>section</Name>)</Call></Raise>
       </ExceptHandler></TryExcept> <Expr><Call><Attribute><Name>opts</Name>.update</Attribute>(<Attribute><Name>self</Name>._defaults</Attribute>)</Call></Expr>
        <If>if <Compare><Str>'__name__'</Str> in <Name>opts</Name></Compare>:
            <Delete>del <Subscript><Name>opts</Name>[<Index><Str>'__name__'</Str></Index>]</Subscript></Delete>
       </If> <Return>return <Call><Attribute><Name>opts</Name>.keys</Attribute>()</Call></Return>

   </FunctionDef> <FunctionDef>def read(<Name>self</Name>, <Name>filenames</Name>):
        <Expr><Str>"""Read and parse a filename or a list of filenames.

        Files that cannot be opened are silently ignored; this is
        designed so that you can specify a list of potential
        configuration file locations (e.g. current directory, user's
        home directory, systemwide directory), and all existing
        configuration files in the list will be read.  A single
        filename may also be given.
        """</Str></Expr>
        <If>if <Call><Name>isinstance</Name>(<Name>filenames</Name>, <Name>basestring</Name>)</Call>:
            <Assign><Name>filenames</Name> = <List>[<Name>filenames</Name>]</List></Assign>
       </If> <For>for <Name>filename</Name> in <Name>filenames</Name>:
            <TryExcept>try:
                <Assign><Name>fp</Name> = <Call><Name>open</Name>(<Name>filename</Name>)</Call></Assign>
            <ExceptHandler>except <Name>IOError</Name>:
                <Continue>continue</Continue>
           </ExceptHandler></TryExcept> <Expr><Call><Attribute><Name>self</Name>._read</Attribute>(<Name>fp</Name>, <Name>filename</Name>)</Call></Expr>
            <Expr><Call><Attribute><Name>fp</Name>.close</Attribute>()</Call></Expr>

   </For></FunctionDef> <FunctionDef>def readfp(<Name>self</Name>, <Name>fp</Name>, <Name>filename</Name>=<Name>None</Name>):
        <Expr><Str>"""Like read() but the argument must be a file-like object.

        The `fp' argument must have a `readline' method.  Optional
        second argument is the `filename', which if not given, is
        taken from fp.name.  If fp has no `name' attribute, `&lt;???&gt;' is
        used.

        """</Str></Expr>
        <If>if <Compare><Name>filename</Name> is <Name>None</Name></Compare>:
            <TryExcept>try:
                <Assign><Name>filename</Name> = <Attribute><Name>fp</Name>.name</Attribute></Assign>
            <ExceptHandler>except <Name>AttributeError</Name>:
                <Assign><Name>filename</Name> = <Str>'&lt;???&gt;'</Str></Assign>
       </ExceptHandler></TryExcept></If> <Expr><Call><Attribute><Name>self</Name>._read</Attribute>(<Name>fp</Name>, <Name>filename</Name>)</Call></Expr>

   </FunctionDef> <FunctionDef>def get(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>):
        <Assign><Name>opt</Name> = <Call><Attribute><Name>self</Name>.optionxform</Attribute>(<Name>option</Name>)</Call></Assign>
        <If>if <Compare><Name>section</Name> not in <Attribute><Name>self</Name>._sections</Attribute></Compare>:
            <If>if <Compare><Name>section</Name> != <Name>DEFAULTSECT</Name></Compare>:
                <Raise>raise <Call><Name>NoSectionError</Name>(<Name>section</Name>)</Call></Raise>
           </If> <If>if <Compare><Name>opt</Name> in <Attribute><Name>self</Name>._defaults</Attribute></Compare>:
                <Return>return <Subscript><Attribute><Name>self</Name>._defaults</Attribute>[<Index><Name>opt</Name></Index>]</Subscript></Return>
            else:
                <Raise>raise <Call><Name>NoOptionError</Name>(<Name>option</Name>, <Name>section</Name>)</Call></Raise>
       </If> <If>elif <Compare><Name>opt</Name> in <Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript></Compare>:
            <Return>return <Subscript><Attribute><Name>self</Name>._sections</Attribute><Subscript>[<Index><Name>section</Name></Index>]</Subscript>[<Index><Name>opt</Name></Index>]</Subscript></Return>
        <If>elif <Compare><Name>opt</Name> in <Attribute><Name>self</Name>._defaults</Attribute></Compare>:
            <Return>return <Subscript><Attribute><Name>self</Name>._defaults</Attribute>[<Index><Name>opt</Name></Index>]</Subscript></Return>
        else:
            <Raise>raise <Call><Name>NoOptionError</Name>(<Name>option</Name>, <Name>section</Name>)</Call></Raise>

   </If></If></If></FunctionDef> <FunctionDef>def items(<Name>self</Name>, <Name>section</Name>):
        <TryExcept>try:
            <Assign><Name>d2</Name> = <Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript></Assign>
        <ExceptHandler>except <Name>KeyError</Name>:
            <If>if <Compare><Name>section</Name> != <Name>DEFAULTSECT</Name></Compare>:
                <Raise>raise <Call><Name>NoSectionError</Name>(<Name>section</Name>)</Call></Raise>
           </If> <Assign><Name>d2</Name> = <Dict>{}</Dict></Assign>
       </ExceptHandler></TryExcept> <Assign><Name>d</Name> = <Call><Attribute><Attribute><Name>self</Name>._defaults</Attribute>.copy</Attribute>()</Call></Assign>
        <Expr><Call><Attribute><Name>d</Name>.update</Attribute>(<Name>d2</Name>)</Call></Expr>
        <If>if <Compare><Str>"__name__"</Str> in <Name>d</Name></Compare>:
            <Delete>del <Subscript><Name>d</Name>[<Index><Str>"__name__"</Str></Index>]</Subscript></Delete>
       </If> <Return>return <Call><Attribute><Name>d</Name>.items</Attribute>()</Call></Return>

   </FunctionDef> <FunctionDef>def _get(<Name>self</Name>, <Name>section</Name>, <Name>conv</Name>, <Name>option</Name>):
        <Return>return <Call><Name>conv</Name>(<Call><Attribute><Name>self</Name>.get</Attribute>(<Name>section</Name>, <Name>option</Name>)</Call>)</Call></Return>

   </FunctionDef> <FunctionDef>def getint(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>):
        <Return>return <Call><Attribute><Name>self</Name>._get</Attribute>(<Name>section</Name>, <Name>int</Name>, <Name>option</Name>)</Call></Return>

   </FunctionDef> <FunctionDef>def getfloat(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>):
        <Return>return <Call><Attribute><Name>self</Name>._get</Attribute>(<Name>section</Name>, <Name>float</Name>, <Name>option</Name>)</Call></Return>

   </FunctionDef> <Assign><Name>_boolean_states</Name> = <Dict>{<Str>'1'</Str>: <Name>True</Name>, <Str>'yes'</Str>: <Name>True</Name>, <Str>'true'</Str>: <Name>True</Name>, <Str>'on'</Str>: <Name>True</Name>,
                       <Str>'0'</Str>: <Name>False</Name>, <Str>'no'</Str>: <Name>False</Name>, <Str>'false'</Str>: <Name>False</Name>, <Str>'off'</Str>: <Name>False</Name>}</Dict></Assign>

    <FunctionDef>def getboolean(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>):
        <Assign><Name>v</Name> = <Call><Attribute><Name>self</Name>.get</Attribute>(<Name>section</Name>, <Name>option</Name>)</Call></Assign>
        <If>if <Compare><Call><Attribute><Name>v</Name>.lower</Attribute>()</Call> not in <Attribute><Name>self</Name>._boolean_states</Attribute></Compare>:
            <Raise>raise <Name>ValueError</Name>, <BinOp><Str>'Not a boolean: %s'</Str> % <Name>v</Name></BinOp></Raise>
       </If> <Return>return <Subscript><Attribute><Name>self</Name>._boolean_states</Attribute>[<Index><Call><Attribute><Name>v</Name>.lower</Attribute>()</Call></Index>]</Subscript></Return>

   </FunctionDef> <FunctionDef>def optionxform(<Name>self</Name>, <Name>optionstr</Name>):
        <Return>return <Call><Attribute><Name>optionstr</Name>.lower</Attribute>()</Call></Return>

   </FunctionDef> <FunctionDef>def has_option(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>):
        <Expr><Str>"""Check for the existence of a given option in a given section."""</Str></Expr>
        <If>if <BoolOp><UnaryOp>not <Name>section</Name></UnaryOp> or <Compare><Name>section</Name> == <Name>DEFAULTSECT</Name></Compare></BoolOp>:
            <Assign><Name>option</Name> = <Call><Attribute><Name>self</Name>.optionxform</Attribute>(<Name>option</Name>)</Call></Assign>
            <Return>return <Compare><Name>option</Name> in <Attribute><Name>self</Name>._defaults</Attribute></Compare></Return>
        <If>elif <Compare><Name>section</Name> not in <Attribute><Name>self</Name>._sections</Attribute></Compare>:
            <Return>return <Name>False</Name></Return>
        else:
            <Assign><Name>option</Name> = <Call><Attribute><Name>self</Name>.optionxform</Attribute>(<Name>option</Name>)</Call></Assign>
            <Return>return <BoolOp>(<Compare><Name>option</Name> in <Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript></Compare>
                    or <Compare><Name>option</Name> in <Attribute><Name>self</Name>._defaults</Attribute></Compare>)</BoolOp></Return>

   </If></If></FunctionDef> <FunctionDef>def set(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>, <Name>value</Name>):
        <Expr><Str>"""Set an option."""</Str></Expr>
        <If>if <BoolOp><UnaryOp>not <Name>section</Name></UnaryOp> or <Compare><Name>section</Name> == <Name>DEFAULTSECT</Name></Compare></BoolOp>:
            <Assign><Name>sectdict</Name> = <Attribute><Name>self</Name>._defaults</Attribute></Assign>
        else:
            <TryExcept>try:
                <Assign><Name>sectdict</Name> = <Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript></Assign>
            <ExceptHandler>except <Name>KeyError</Name>:
                <Raise>raise <Call><Name>NoSectionError</Name>(<Name>section</Name>)</Call></Raise>
       </ExceptHandler></TryExcept></If> <Assign><Subscript><Name>sectdict</Name>[<Index><Call><Attribute><Name>self</Name>.optionxform</Attribute>(<Name>option</Name>)</Call></Index>]</Subscript> = <Name>value</Name></Assign>

   </FunctionDef> <FunctionDef>def write(<Name>self</Name>, <Name>fp</Name>):
        <Expr><Str>"""Write an .ini-format representation of the configuration state."""</Str></Expr>
        <If>if <Attribute><Name>self</Name>._defaults</Attribute>:
            <Expr><Call><Attribute><Name>fp</Name>.write</Attribute>(<BinOp><Str>"[%s]\n"</Str> % <Name>DEFAULTSECT</Name></BinOp>)</Call></Expr>
            <For>for <Tuple>(<Name>key</Name>, <Name>value</Name>)</Tuple> in <Call><Attribute><Attribute><Name>self</Name>._defaults</Attribute>.items</Attribute>()</Call>:
                <Expr><Call><Attribute><Name>fp</Name>.write</Attribute>(<BinOp><Str>"%s = %s\n"</Str> % <Tuple>(<Name>key</Name>, <Call><Name>str</Name><Attribute><Call>(<Name>value</Name>)</Call>.replace</Attribute>(<Str>'\n'</Str>, <Str>'\n\t'</Str>)</Call>)</Tuple></BinOp>)</Call></Expr>
           </For> <Expr><Call><Attribute><Name>fp</Name>.write</Attribute>(<Str>"\n"</Str>)</Call></Expr>
       </If> <For>for <Name>section</Name> in <Attribute><Name>self</Name>._sections</Attribute>:
            <Expr><Call><Attribute><Name>fp</Name>.write</Attribute>(<BinOp><Str>"[%s]\n"</Str> % <Name>section</Name></BinOp>)</Call></Expr>
            <For>for <Tuple>(<Name>key</Name>, <Name>value</Name>)</Tuple> in <Call><Attribute><Name>self</Name>._sections</Attribute><Attribute><Subscript>[<Index><Name>section</Name></Index>]</Subscript>.items</Attribute>()</Call>:
                <If>if <Compare><Name>key</Name> != <Str>"__name__"</Str></Compare>:
                    <Expr><Call><Attribute><Name>fp</Name>.write</Attribute>(<BinOp><Str>"%s = %s\n"</Str> %
                             <Tuple>(<Name>key</Name>, <Call><Name>str</Name><Attribute><Call>(<Name>value</Name>)</Call>.replace</Attribute>(<Str>'\n'</Str>, <Str>'\n\t'</Str>)</Call>)</Tuple></BinOp>)</Call></Expr>
           </If></For> <Expr><Call><Attribute><Name>fp</Name>.write</Attribute>(<Str>"\n"</Str>)</Call></Expr>

   </For></FunctionDef> <FunctionDef>def remove_option(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>):
        <Expr><Str>"""Remove an option."""</Str></Expr>
        <If>if <BoolOp><UnaryOp>not <Name>section</Name></UnaryOp> or <Compare><Name>section</Name> == <Name>DEFAULTSECT</Name></Compare></BoolOp>:
            <Assign><Name>sectdict</Name> = <Attribute><Name>self</Name>._defaults</Attribute></Assign>
        else:
            <TryExcept>try:
                <Assign><Name>sectdict</Name> = <Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript></Assign>
            <ExceptHandler>except <Name>KeyError</Name>:
                <Raise>raise <Call><Name>NoSectionError</Name>(<Name>section</Name>)</Call></Raise>
       </ExceptHandler></TryExcept></If> <Assign><Name>option</Name> = <Call><Attribute><Name>self</Name>.optionxform</Attribute>(<Name>option</Name>)</Call></Assign>
        <Assign><Name>existed</Name> = <Compare><Name>option</Name> in <Name>sectdict</Name></Compare></Assign>
        <If>if <Name>existed</Name>:
            <Delete>del <Subscript><Name>sectdict</Name>[<Index><Name>option</Name></Index>]</Subscript></Delete>
       </If> <Return>return <Name>existed</Name></Return>

   </FunctionDef> <FunctionDef>def remove_section(<Name>self</Name>, <Name>section</Name>):
        <Expr><Str>"""Remove a file section."""</Str></Expr>
        <Assign><Name>existed</Name> = <Compare><Name>section</Name> in <Attribute><Name>self</Name>._sections</Attribute></Compare></Assign>
        <If>if <Name>existed</Name>:
            <Delete>del <Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript></Delete>
       </If> <Return>return <Name>existed</Name></Return>

    #
    # Regular expressions for parsing section headers and options.
    #
   </FunctionDef> <Assign><Name>SECTCRE</Name> = <Call><Attribute><Name>re</Name>.compile</Attribute>(
        <Str>r'\['                                 # [
        r'(?P&lt;header&gt;[^]]+)'                  # very permissive!
        r'\]'</Str>                                 # ]
        )</Call></Assign>
    <Assign><Name>OPTCRE</Name> = <Call><Attribute><Name>re</Name>.compile</Attribute>(
        <Str>r'(?P&lt;option&gt;[^:=\s][^:=]*)'          # very permissive!
        r'\s*(?P&lt;vi&gt;[:=])\s*'                 # any number of space/tab,
                                              # followed by separator
                                              # (either : or =), followed
                                              # by any # space/tab
        r'(?P&lt;value&gt;.*)$'</Str>                     # everything up to eol
        )</Call></Assign>

    <FunctionDef>def _read(<Name>self</Name>, <Name>fp</Name>, <Name>fpname</Name>):
        <Expr><Str>"""Parse a sectioned setup file.

        The sections in setup file contains a title line at the top,
        indicated by a name in square brackets (`[]'), plus key/value
        options lines, indicated by `name: value' format lines.
        Continuations are represented by an embedded newline then
        leading whitespace.  Blank lines, lines beginning with a '#',
        and just about everything else are ignored.
        """</Str></Expr>
        <Assign><Name>cursect</Name> = <Name>None</Name></Assign>                            # None, or a dictionary
        <Assign><Name>optname</Name> = <Name>None</Name></Assign>
        <Assign><Name>lineno</Name> = <Num>0</Num></Assign>
        <Assign><Name>e</Name> = <Name>None</Name></Assign>                                  # None, or an exception
        <While>while <Name>True</Name>:
            <Assign><Name>line</Name> = <Call><Attribute><Name>fp</Name>.readline</Attribute>()</Call></Assign>
            <If>if <UnaryOp>not <Name>line</Name></UnaryOp>:
                <Break>break</Break>
           </If> <Assign><Name>lineno</Name> = <BinOp><Name>lineno</Name> + <Num>1</Num></BinOp></Assign>
            # comment or blank line?
            <If>if <BoolOp><Compare><Call><Attribute><Name>line</Name>.strip</Attribute>()</Call> == <Str>''</Str></Compare> or <Compare><Subscript><Name>line</Name>[<Index><Num>0</Num></Index>]</Subscript> in <Str>'#;'</Str></Compare></BoolOp>:
                <Continue>continue</Continue>
           </If> <If>if <BoolOp><Compare><Call><Attribute><Name>line</Name>.split</Attribute><Call>(<Name>None</Name>, <Num>1</Num>)</Call><Attribute><Subscript>[<Index><Num>0</Num></Index>]</Subscript>.lower</Attribute>()</Call> == <Str>'rem'</Str></Compare> and <Compare><Subscript><Name>line</Name>[<Index><Num>0</Num></Index>]</Subscript> in <Str>"rR"</Str></Compare></BoolOp>:
                # no leading whitespace
                <Continue>continue</Continue>
            # continuation line?
           </If> <If>if <BoolOp><Call><Name>line</Name><Attribute><Subscript>[<Index><Num>0</Num></Index>]</Subscript>.isspace</Attribute>()</Call> and <Compare><Name>cursect</Name> is not <Name>None</Name></Compare> and <Name>optname</Name></BoolOp>:
                <Assign><Name>value</Name> = <Call><Attribute><Name>line</Name>.strip</Attribute>()</Call></Assign>
                <If>if <Name>value</Name>:
                    <Assign><Subscript><Name>cursect</Name>[<Index><Name>optname</Name></Index>]</Subscript> = <BinOp><Str>"%s\n%s"</Str> % <Tuple>(<Subscript><Name>cursect</Name>[<Index><Name>optname</Name></Index>]</Subscript>, <Name>value</Name>)</Tuple></BinOp></Assign>
            # a section header or option header?
           </If> else:
                # is it a section header?
                <Assign><Name>mo</Name> = <Call><Attribute><Attribute><Name>self</Name>.SECTCRE</Attribute>.match</Attribute>(<Name>line</Name>)</Call></Assign>
                <If>if <Name>mo</Name>:
                    <Assign><Name>sectname</Name> = <Call><Attribute><Name>mo</Name>.group</Attribute>(<Str>'header'</Str>)</Call></Assign>
                    <If>if <Compare><Name>sectname</Name> in <Attribute><Name>self</Name>._sections</Attribute></Compare>:
                        <Assign><Name>cursect</Name> = <Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>sectname</Name></Index>]</Subscript></Assign>
                    <If>elif <Compare><Name>sectname</Name> == <Name>DEFAULTSECT</Name></Compare>:
                        <Assign><Name>cursect</Name> = <Attribute><Name>self</Name>._defaults</Attribute></Assign>
                    else:
                        <Assign><Name>cursect</Name> = <Dict>{<Str>'__name__'</Str>: <Name>sectname</Name>}</Dict></Assign>
                        <Assign><Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>sectname</Name></Index>]</Subscript> = <Name>cursect</Name></Assign>
                    # So sections can't start with a continuation line
                   </If></If> <Assign><Name>optname</Name> = <Name>None</Name></Assign>
                # no section header in the file?
                <If>elif <Compare><Name>cursect</Name> is <Name>None</Name></Compare>:
                    <Raise>raise <Call><Name>MissingSectionHeaderError</Name>(<Name>fpname</Name>, <Name>lineno</Name>, <Repr>`<Name>line</Name>`</Repr>)</Call></Raise>
                # an option line?
                else:
                    <Assign><Name>mo</Name> = <Call><Attribute><Attribute><Name>self</Name>.OPTCRE</Attribute>.match</Attribute>(<Name>line</Name>)</Call></Assign>
                    <If>if <Name>mo</Name>:
                        <Assign><Tuple><Name>optname</Name>, <Name>vi</Name>, <Name>optval</Name></Tuple> = <Call><Attribute><Name>mo</Name>.group</Attribute>(<Str>'option'</Str>, <Str>'vi'</Str>, <Str>'value'</Str>)</Call></Assign>
                        <If>if <BoolOp><Compare><Name>vi</Name> in <Tuple>(<Str>'='</Str>, <Str>':'</Str>)</Tuple></Compare> and <Compare><Str>';'</Str> in <Name>optval</Name></Compare></BoolOp>:
                            # ';' is a comment delimiter only if it follows
                            # a spacing character
                            <Assign><Name>pos</Name> = <Call><Attribute><Name>optval</Name>.find</Attribute>(<Str>';'</Str>)</Call></Assign>
                            <If>if <BoolOp><Compare><Name>pos</Name> != <Num>-1</Num></Compare> and <Call><Name>optval</Name><Attribute><Subscript>[<Index><BinOp><Name>pos</Name>-<Num>1</Num></BinOp></Index>]</Subscript>.isspace</Attribute>()</Call></BoolOp>:
                                <Assign><Name>optval</Name> = <Subscript><Name>optval</Name>[<Slice>:<Name>pos</Name></Slice>]</Subscript></Assign>
                       </If></If> <Assign><Name>optval</Name> = <Call><Attribute><Name>optval</Name>.strip</Attribute>()</Call></Assign>
                        # allow empty values
                        <If>if <Compare><Name>optval</Name> == <Str>'""'</Str></Compare>:
                            <Assign><Name>optval</Name> = <Str>''</Str></Assign>
                       </If> <Assign><Name>optname</Name> = <Call><Attribute><Name>self</Name>.optionxform</Attribute>(<Call><Attribute><Name>optname</Name>.rstrip</Attribute>()</Call>)</Call></Assign>
                        <Assign><Subscript><Name>cursect</Name>[<Index><Name>optname</Name></Index>]</Subscript> = <Name>optval</Name></Assign>
                    else:
                        # a non-fatal parsing error occurred.  set up the
                        # exception but keep going. the exception will be
                        # raised at the end of the file and will contain a
                        # list of all bogus lines
                        <If>if <UnaryOp>not <Name>e</Name></UnaryOp>:
                            <Assign><Name>e</Name> = <Call><Name>ParsingError</Name>(<Name>fpname</Name>)</Call></Assign>
                       </If> <Expr><Call><Attribute><Name>e</Name>.append</Attribute>(<Name>lineno</Name>, <Repr>`<Name>line</Name>`</Repr>)</Call></Expr>
        # if any parsing errors occurred, raise an exception
       </If></If></If></If></While> <If>if <Name>e</Name>:
            <Raise>raise <Name>e</Name></Raise>


</If></FunctionDef></ClassDef><ClassDef>class ConfigParser(<Name>RawConfigParser</Name>):

    <FunctionDef>def get(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>, <Name>raw</Name>=<Name>False</Name>, <Name>vars</Name>=<Name>None</Name>):
        <Expr><Str>"""Get an option value for a given section.

        All % interpolations are expanded in the return values, based on the
        defaults passed into the constructor, unless the optional argument
        `raw' is true.  Additional substitutions may be provided using the
        `vars' argument, which must be a dictionary whose contents overrides
        any pre-existing defaults.

        The section DEFAULT is special.
        """</Str></Expr>
        <Assign><Name>d</Name> = <Call><Attribute><Attribute><Name>self</Name>._defaults</Attribute>.copy</Attribute>()</Call></Assign>
        <TryExcept>try:
            <Expr><Call><Attribute><Name>d</Name>.update</Attribute>(<Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript>)</Call></Expr>
        <ExceptHandler>except <Name>KeyError</Name>:
            <If>if <Compare><Name>section</Name> != <Name>DEFAULTSECT</Name></Compare>:
                <Raise>raise <Call><Name>NoSectionError</Name>(<Name>section</Name>)</Call></Raise>
        # Update with the entry specific variables
       </If></ExceptHandler></TryExcept> <If>if <Compare><Name>vars</Name> is not <Name>None</Name></Compare>:
            <Expr><Call><Attribute><Name>d</Name>.update</Attribute>(<Name>vars</Name>)</Call></Expr>
       </If> <Assign><Name>option</Name> = <Call><Attribute><Name>self</Name>.optionxform</Attribute>(<Name>option</Name>)</Call></Assign>
        <TryExcept>try:
            <Assign><Name>value</Name> = <Subscript><Name>d</Name>[<Index><Name>option</Name></Index>]</Subscript></Assign>
        <ExceptHandler>except <Name>KeyError</Name>:
            <Raise>raise <Call><Name>NoOptionError</Name>(<Name>option</Name>, <Name>section</Name>)</Call></Raise>

       </ExceptHandler></TryExcept> <If>if <Name>raw</Name>:
            <Return>return <Name>value</Name></Return>
        else:
            <Return>return <Call><Attribute><Name>self</Name>._interpolate</Attribute>(<Name>section</Name>, <Name>option</Name>, <Name>value</Name>, <Name>d</Name>)</Call></Return>

   </If></FunctionDef> <FunctionDef>def items(<Name>self</Name>, <Name>section</Name>, <Name>raw</Name>=<Name>False</Name>, <Name>vars</Name>=<Name>None</Name>):
        <Expr><Str>"""Return a list of tuples with (name, value) for each option
        in the section.

        All % interpolations are expanded in the return values, based on the
        defaults passed into the constructor, unless the optional argument
        `raw' is true.  Additional substitutions may be provided using the
        `vars' argument, which must be a dictionary whose contents overrides
        any pre-existing defaults.

        The section DEFAULT is special.
        """</Str></Expr>
        <Assign><Name>d</Name> = <Call><Attribute><Attribute><Name>self</Name>._defaults</Attribute>.copy</Attribute>()</Call></Assign>
        <TryExcept>try:
            <Expr><Call><Attribute><Name>d</Name>.update</Attribute>(<Subscript><Attribute><Name>self</Name>._sections</Attribute>[<Index><Name>section</Name></Index>]</Subscript>)</Call></Expr>
        <ExceptHandler>except <Name>KeyError</Name>:
            <If>if <Compare><Name>section</Name> != <Name>DEFAULTSECT</Name></Compare>:
                <Raise>raise <Call><Name>NoSectionError</Name>(<Name>section</Name>)</Call></Raise>
        # Update with the entry specific variables
       </If></ExceptHandler></TryExcept> <If>if <Name>vars</Name>:
            <Expr><Call><Attribute><Name>d</Name>.update</Attribute>(<Name>vars</Name>)</Call></Expr>
       </If> <Assign><Name>options</Name> = <Call><Attribute><Name>d</Name>.keys</Attribute>()</Call></Assign>
        <If>if <Compare><Str>"__name__"</Str> in <Name>options</Name></Compare>:
            <Expr><Call><Attribute><Name>options</Name>.remove</Attribute>(<Str>"__name__"</Str>)</Call></Expr>
       </If> <If>if <Name>raw</Name>:
            <Return>return <ListComp>[<Tuple>(<Name>option</Name>, <Subscript><Name>d</Name>[<Index><Name>option</Name></Index>]</Subscript>)</Tuple>
                    for <Name>option</Name> in <Name>options</Name>]</ListComp></Return>
        else:
            <Return>return <ListComp>[<Tuple>(<Name>option</Name>, <Call><Attribute><Name>self</Name>._interpolate</Attribute>(<Name>section</Name>, <Name>option</Name>, <Subscript><Name>d</Name>[<Index><Name>option</Name></Index>]</Subscript>, <Name>d</Name>)</Call>)</Tuple>
                    for <Name>option</Name> in <Name>options</Name>]</ListComp></Return>

   </If></FunctionDef> <FunctionDef>def _interpolate(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>, <Name>rawval</Name>, <Name>vars</Name>):
        # do the string interpolation
        <Assign><Name>value</Name> = <Name>rawval</Name></Assign>
        <Assign><Name>depth</Name> = <Name>MAX_INTERPOLATION_DEPTH</Name></Assign>
        <While>while <Name>depth</Name>:                    # Loop through this until it's done
            <AugAssign><Name>depth</Name> -= <Num>1</Num></AugAssign>
            <If>if <Compare><Call><Attribute><Name>value</Name>.find</Attribute>(<Str>"%("</Str>)</Call> != <Num>-1</Num></Compare>:
                <TryExcept>try:
                    <Assign><Name>value</Name> = <BinOp><Name>value</Name> % <Name>vars</Name></BinOp></Assign>
                <ExceptHandler>except <Name>KeyError</Name>, <Name>e</Name>:
                    <Raise>raise <Call><Name>InterpolationMissingOptionError</Name>(
                        <Name>option</Name>, <Name>section</Name>, <Name>rawval</Name>, <Subscript><Name>e</Name>[<Index><Num>0</Num></Index>]</Subscript>)</Call></Raise>
           </ExceptHandler></TryExcept> else:
                <Break>break</Break>
       </If></While> <If>if <Compare><Call><Attribute><Name>value</Name>.find</Attribute>(<Str>"%("</Str>)</Call> != <Num>-1</Num></Compare>:
            <Raise>raise <Call><Name>InterpolationDepthError</Name>(<Name>option</Name>, <Name>section</Name>, <Name>rawval</Name>)</Call></Raise>
       </If> <Return>return <Name>value</Name></Return>


</FunctionDef></ClassDef><ClassDef>class SafeConfigParser(<Name>ConfigParser</Name>):

    <FunctionDef>def _interpolate(<Name>self</Name>, <Name>section</Name>, <Name>option</Name>, <Name>rawval</Name>, <Name>vars</Name>):
        # do the string interpolation
        <Assign><Name>L</Name> = <List>[]</List></Assign>
        <Expr><Call><Attribute><Name>self</Name>._interpolate_some</Attribute>(<Name>option</Name>, <Name>L</Name>, <Name>rawval</Name>, <Name>section</Name>, <Name>vars</Name>, <Num>1</Num>)</Call></Expr>
        <Return>return <Call><Attribute><Str>''</Str>.join</Attribute>(<Name>L</Name>)</Call></Return>

   </FunctionDef> <Assign><Name>_interpvar_match</Name> = <Attribute><Attribute><Name>re</Name>.compile</Attribute><Call>(<Str>r"%\(([^)]+)\)s"</Str>)</Call>.match</Attribute></Assign>

    <FunctionDef>def _interpolate_some(<Name>self</Name>, <Name>option</Name>, <Name>accum</Name>, <Name>rest</Name>, <Name>section</Name>, <Name>map</Name>, <Name>depth</Name>):
        <If>if <Compare><Name>depth</Name> &gt; <Name>MAX_INTERPOLATION_DEPTH</Name></Compare>:
            <Raise>raise <Call><Name>InterpolationDepthError</Name>(<Name>option</Name>, <Name>section</Name>, <Name>rest</Name>)</Call></Raise>
       </If> <While>while <Name>rest</Name>:
            <Assign><Name>p</Name> = <Call><Attribute><Name>rest</Name>.find</Attribute>(<Str>"%"</Str>)</Call></Assign>
            <If>if <Compare><Name>p</Name> &lt; <Num>0</Num></Compare>:
                <Expr><Call><Attribute><Name>accum</Name>.append</Attribute>(<Name>rest</Name>)</Call></Expr>
                <Return>return</Return>
           </If> <If>if <Compare><Name>p</Name> &gt; <Num>0</Num></Compare>:
                <Expr><Call><Attribute><Name>accum</Name>.append</Attribute>(<Subscript><Name>rest</Name>[<Slice>:<Name>p</Name></Slice>]</Subscript>)</Call></Expr>
                <Assign><Name>rest</Name> = <Subscript><Name>rest</Name>[<Slice><Name>p</Name>:</Slice>]</Subscript></Assign>
            # p is no longer used
           </If> <Assign><Name>c</Name> = <Subscript><Name>rest</Name>[<Slice><Num>1</Num>:<Num>2</Num></Slice>]</Subscript></Assign>
            <If>if <Compare><Name>c</Name> == <Str>"%"</Str></Compare>:
                <Expr><Call><Attribute><Name>accum</Name>.append</Attribute>(<Str>"%"</Str>)</Call></Expr>
                <Assign><Name>rest</Name> = <Subscript><Name>rest</Name>[<Slice><Num>2</Num>:</Slice>]</Subscript></Assign>
            <If>elif <Compare><Name>c</Name> == <Str>"("</Str></Compare>:
                <Assign><Name>m</Name> = <Call><Attribute><Name>self</Name>._interpvar_match</Attribute>(<Name>rest</Name>)</Call></Assign>
                <If>if <Compare><Name>m</Name> is <Name>None</Name></Compare>:
                    <Raise>raise <Call><Name>InterpolationSyntaxError</Name>(<Name>option</Name>, <Name>section</Name>,
                        <BinOp><Str>"bad interpolation variable reference %r"</Str> % <Name>rest</Name></BinOp>)</Call></Raise>
               </If> <Assign><Name>var</Name> = <Call><Attribute><Name>m</Name>.group</Attribute>(<Num>1</Num>)</Call></Assign>
                <Assign><Name>rest</Name> = <Subscript><Name>rest</Name>[<Slice><Call><Attribute><Name>m</Name>.end</Attribute>()</Call>:</Slice>]</Subscript></Assign>
                <TryExcept>try:
                    <Assign><Name>v</Name> = <Subscript><Name>map</Name>[<Index><Name>var</Name></Index>]</Subscript></Assign>
                <ExceptHandler>except <Name>KeyError</Name>:
                    <Raise>raise <Call><Name>InterpolationMissingOptionError</Name>(
                        <Name>option</Name>, <Name>section</Name>, <Name>rest</Name>, <Name>var</Name>)</Call></Raise>
               </ExceptHandler></TryExcept> <If>if <Compare><Str>"%"</Str> in <Name>v</Name></Compare>:
                    <Expr><Call><Attribute><Name>self</Name>._interpolate_some</Attribute>(<Name>option</Name>, <Name>accum</Name>, <Name>v</Name>,
                                           <Name>section</Name>, <Name>map</Name>, <BinOp><Name>depth</Name> + <Num>1</Num></BinOp>)</Call></Expr>
                else:
                    <Expr><Call><Attribute><Name>accum</Name>.append</Attribute>(<Name>v</Name>)</Call></Expr>
           </If> else:
                <Raise>raise <Call><Name>InterpolationSyntaxError</Name>(
                    <Name>option</Name>, <Name>section</Name>,
                    <BinOp><Str>"'%' must be followed by '%' or '(', found: "</Str> + <Repr>`<Name>ret</Name>`</Repr></BinOp>)</Call></Raise></If></If></While></FunctionDef></ClassDef></Module>
