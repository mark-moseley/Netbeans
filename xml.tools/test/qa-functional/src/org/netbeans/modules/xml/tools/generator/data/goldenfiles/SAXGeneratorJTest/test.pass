
=== Handler Interface:

public interface BHandler extends ContentHandler {
    /** A container element end event handling method.
     *
     *
     */
    public void end_Books() throws SAXException;
    
    /** A container element end event handling method.
     *
     *
     */
    public void end_Custom() throws SAXException;
    
    /** A container element end event handling method.
     *
     *
     */
    public void end_productHandlerMethod() throws SAXException;
    
    /** A data element event handling method.
     * @param data value or null
     * @param meta attributes
     *
     *
     */
    public void handle_Custom(final java.lang.String data, final Attributes meta) throws SAXException;
    
    /** A data element event handling method.
     * @param data value or null
     * @param meta attributes
     *
     *
     */
    public void handle_Descript(final java.lang.String data, final Attributes meta) throws SAXException;
    
    /** An empty element event handling method.
     * @param data value or null
     *
     *
     */
    public void handle_Image(final Attributes meta) throws SAXException;
    
    /** A data element event handling method.
     * @param data value or null
     * @param meta attributes
     *
     *
     */
    public void handle_Price(final int data, final Attributes meta) throws SAXException;
    
    /** A data element event handling method.
     * @param data value or null
     * @param meta attributes
     *
     *
     */
    public void handle_inc_level_2(final java.lang.String data, final Attributes meta) throws SAXException;
    
    /** A data element event handling method.
     * @param data value or null
     * @param meta attributes
     *
     *
     */
    public void handle_x_include(final java.lang.String data, final Attributes meta) throws SAXException;
    
    /** A container element start event handling method.
     * @param meta attributes
     *
     *
     */
    public void start_Books(final Attributes meta) throws SAXException;
    
    /** A container element start event handling method.
     * @param meta attributes
     *
     *
     */
    public void start_Custom(final Attributes meta) throws SAXException;
    
    /** A container element start event handling method.
     * @param meta attributes
     *
     *
     */
    public void start_productHandlerMethod(final Attributes meta) throws SAXException;
    
    
}
=== Handler Implementation:

public class BHImpl implements BHandler {
    public static final boolean DEBUG = false;
    
    /** Receive notification of character data.
     *
     * <p>The Parser will call this method to report each chunk of
     * character data.  SAX parsers may return all contiguous character
     * data in a single chunk, or they may split it into several
     * chunks; however, all of the characters in any single event
     * must come from the same external entity so that the Locator
     * provides useful information.</p>
     *
     * <p>The application must not attempt to read from the array
     * outside of the specified range.</p>
     *
     * <p>Note that some parsers will report whitespace in element
     * content using the {@link #ignorableWhitespace ignorableWhitespace}
     * method rather than this one (validating parsers <em>must</em>
     * do so).</p>
     *
     * @param ch The characters from the XML document.
     * @param start The start position in the array.
     * @param length The number of characters to read from the array.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #ignorableWhitespace
     * @see org.xml.sax.Locator
     *
     */
    public void characters(char[] ch, int start, int length) throws SAXException {
    }
    
    /** Receive notification of the end of a document.
     *
     * <p>The SAX parser will invoke this method only once, and it will
     * be the last method invoked during the parse.  The parser shall
     * not invoke this method until it has either abandoned parsing
     * (because of an unrecoverable error) or reached the end of
     * input.</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #startDocument
     *
     */
    public void endDocument() throws SAXException {
    }
    
    /** Receive notification of the end of an element.
     *
     * <p>The SAX parser will invoke this method at the end of every
     * element in the XML document; there will be a corresponding
     * {@link #startElement startElement} event for every endElement
     * event (even when the element is empty).</p>
     *
     * <p>For information on the names, see startElement.</p>
     *
     * @param uri The Namespace URI, or the empty string if the
     *        element has no Namespace URI or if Namespace
     *        processing is not being performed.
     * @param localName The local name (without prefix), or the
     *        empty string if Namespace processing is not being
     *        performed.
     * @param qName The qualified XML 1.0 name (with prefix), or the
     *        empty string if qualified names are not available.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     *
     */
    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
    }
    
    /** End the scope of a prefix-URI mapping.
     *
     * <p>See {@link #startPrefixMapping startPrefixMapping} for
     * details.  This event will always occur after the corresponding
     * {@link #endElement endElement} event, but the order of
     * {@link #endPrefixMapping endPrefixMapping} events is not otherwise
     * guaranteed.</p>
     *
     * @param prefix The prefix that was being mapping.
     * @exception org.xml.sax.SAXException The client may throw
     *            an exception during processing.
     * @see #startPrefixMapping
     * @see #endElement
     *
     */
    public void endPrefixMapping(String prefix) throws SAXException {
    }
    
    public void end_Books() throws SAXException {
        if (DEBUG) System.err.println("end_Books()");
    }
    
    public void end_Custom() throws SAXException {
        if (DEBUG) System.err.println("end_Custom()");
    }
    
    public void end_productHandlerMethod() throws SAXException {
        if (DEBUG) System.err.println("end_productHandlerMethod()");
    }
    
    public void handle_Custom(final java.lang.String data, final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("handle_Custom: " + data);
    }
    
    public void handle_Descript(final java.lang.String data, final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("handle_Descript: " + data);
    }
    
    public void handle_Image(final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("handle_Image: " + meta);
    }
    
    public void handle_Price(final int data, final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("handle_Price: " + data);
    }
    
    public void handle_inc_level_2(final java.lang.String data, final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("handle_inc_level_2: " + data);
    }
    
    public void handle_x_include(final java.lang.String data, final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("handle_x_include: " + data);
    }
    
    /** Receive notification of ignorable whitespace in element content.
     *
     * <p>Validating Parsers must use this method to report each chunk
     * of whitespace in element content (see the W3C XML 1.0 recommendation,
     * section 2.10): non-validating parsers may also use this method
     * if they are capable of parsing and using content models.</p>
     *
     * <p>SAX parsers may return all contiguous whitespace in a single
     * chunk, or they may split it into several chunks; however, all of
     * the characters in any single event must come from the same
     * external entity, so that the Locator provides useful
     * information.</p>
     *
     * <p>The application must not attempt to read from the array
     * outside of the specified range.</p>
     *
     * @param ch The characters from the XML document.
     * @param start The start position in the array.
     * @param length The number of characters to read from the array.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #characters
     *
     */
    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
    }
    
    /** Receive notification of a processing instruction.
     *
     * <p>The Parser will invoke this method once for each processing
     * instruction found: note that processing instructions may occur
     * before or after the main document element.</p>
     *
     * <p>A SAX parser must never report an XML declaration (XML 1.0,
     * section 2.8) or a text declaration (XML 1.0, section 4.3.1)
     * using this method.</p>
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if
     *        none was supplied.  The data does not include any
     *        whitespace separating it from the target.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     *
     */
    public void processingInstruction(String target, String data) throws SAXException {
    }
    
    /** Receive an object for locating the origin of SAX document events.
     *
     * <p>SAX parsers are strongly encouraged (though not absolutely
     * required) to supply a locator: if it does so, it must supply
     * the locator to the application by invoking this method before
     * invoking any of the other methods in the ContentHandler
     * interface.</p>
     *
     * <p>The locator allows the application to determine the end
     * position of any document-related event, even if the parser is
     * not reporting an error.  Typically, the application will
     * use this information for reporting its own errors (such as
     * character content that does not match an application's
     * business rules).  The information returned by the locator
     * is probably not sufficient for use with a search engine.</p>
     *
     * <p>Note that the locator will return correct information only
     * during the invocation of the events in this interface.  The
     * application should not attempt to use it at any other time.</p>
     *
     * @param locator An object that can return the location of
     *                any SAX document event.
     * @see org.xml.sax.Locator
     *
     */
    public void setDocumentLocator(Locator locator) {
    }
    
    /** Receive notification of a skipped entity.
     *
     * <p>The Parser will invoke this method once for each entity
     * skipped.  Non-validating processors may skip entities if they
     * have not seen the declarations (because, for example, the
     * entity was declared in an external DTD subset).  All processors
     * may skip external entities, depending on the values of the
     * <code>http://xml.org/sax/features/external-general-entities</code>
     * and the
     * <code>http://xml.org/sax/features/external-parameter-entities</code>
     * properties.</p>
     *
     * @param name The name of the skipped entity.  If it is a
     *        parameter entity, the name will begin with '%', and if
     *        it is the external DTD subset, it will be the string
     *        "[dtd]".
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     *
     */
    public void skippedEntity(String name) throws SAXException {
    }
    
    /** Receive notification of the beginning of a document.
     *
     * <p>The SAX parser will invoke this method only once, before any
     * other methods in this interface or in {@link org.xml.sax.DTDHandler
     * DTDHandler} (except for {@link #setDocumentLocator
     * setDocumentLocator}).</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endDocument
     *
     */
    public void startDocument() throws SAXException {
    }
    
    /** Receive notification of the beginning of an element.
     *
     * <p>The Parser will invoke this method at the beginning of every
     * element in the XML document; there will be a corresponding
     * {@link #endElement endElement} event for every startElement event
     * (even when the element is empty). All of the element's content will be
     * reported, in order, before the corresponding endElement
     * event.</p>
     *
     * <p>This event allows up to three name components for each
     * element:</p>
     *
     * <ol>
     * <li>the Namespace URI;</li>
     * <li>the local name; and</li>
     * <li>the qualified (prefixed) name.</li>
     * </ol>
     *
     * <p>Any or all of these may be provided, depending on the
     * values of the <var>http://xml.org/sax/features/namespaces</var>
     * and the <var>http://xml.org/sax/features/namespace-prefixes</var>
     * properties:</p>
     *
     * <ul>
     * <li>the Namespace URI and local name are required when
     * the namespaces property is <var>true</var> (the default), and are
     * optional when the namespaces property is <var>false</var> (if one is
     * specified, both must be);</li>
     * <li>the qualified name is required when the namespace-prefixes property
     * is <var>true</var>, and is optional when the namespace-prefixes property
     * is <var>false</var> (the default).</li>
     * </ul>
     *
     * <p>Note that the attribute list provided will contain only
     * attributes with explicit values (specified or defaulted):
     * #IMPLIED attributes will be omitted.  The attribute list
     * will contain attributes used for Namespace declarations
     * (xmlns* attributes) only if the
     * <code>http://xml.org/sax/features/namespace-prefixes</code>
     * property is true (it is false by default, and support for a
     * true value is optional).</p>
     *
     * @param uri The Namespace URI, or the empty string if the
     *        element has no Namespace URI or if Namespace
     *        processing is not being performed.
     * @param localName The local name (without prefix), or the
     *        empty string if Namespace processing is not being
     *        performed.
     * @param qName The qualified name (with prefix), or the
     *        empty string if qualified names are not available.
     * @param atts The attributes attached to the element.  If
     *        there are no attributes, it shall be an empty
     *        Attributes object.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement
     * @see org.xml.sax.Attributes
     *
     */
    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
    }
    
    /** Begin the scope of a prefix-URI Namespace mapping.
     *
     * <p>The information from this event is not necessary for
     * normal Namespace processing: the SAX XML reader will
     * automatically replace prefixes for element and attribute
     * names when the <code>http://xml.org/sax/features/namespaces</code>
     * feature is <var>true</var> (the default).</p>
     *
     * <p>There are cases, however, when applications need to
     * use prefixes in character data or in attribute values,
     * where they cannot safely be expanded automatically; the
     * start/endPrefixMapping event supplies the information
     * to the application to expand prefixes in those contexts
     * itself, if necessary.</p>
     *
     * <p>Note that start/endPrefixMapping events are not
     * guaranteed to be properly nested relative to each-other:
     * all startPrefixMapping events will occur before the
     * corresponding {@link #startElement startElement} event,
     * and all {@link #endPrefixMapping endPrefixMapping}
     * events will occur after the corresponding {@link #endElement
     * endElement} event, but their order is not otherwise
     * guaranteed.</p>
     *
     * <p>There should never be start/endPrefixMapping events for the
     * "xml" prefix, since it is predeclared and immutable.</p>
     *
     * @param prefix The Namespace prefix being declared.
     * @param uri The Namespace URI the prefix is mapped to.
     * @exception org.xml.sax.SAXException The client may throw
     *            an exception during processing.
     * @see #endPrefixMapping
     * @see #startElement
     *
     */
    public void startPrefixMapping(String prefix, String uri) throws SAXException {
    }
    
    public void start_Books(final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("start_Books: " + meta);
    }
    
    public void start_Custom(final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("start_Custom: " + meta);
    }
    
    public void start_productHandlerMethod(final Attributes meta) throws SAXException {
        if (DEBUG) System.err.println("start_productHandlerMethod: " + meta);
    }
    
    
}

=== Generated Parser:

/** The class reads XML documents according to specified DTD and
 * translates all related events into BHandler events.
 * <p>Usage sample:
 * <pre>
 *    BParser parser = new BParser(...);
 *    parser.parse(new InputSource("..."));
 * </pre>
 * <p><b>Warning:</b> the class is machine generated. DO NOT MODIFY</p>
 *
 *
 */
public class BParser implements ContentHandler {
    private java.lang.StringBuffer buffer;
    
    private java.util.Stack context;
    
    private BHandler handler;
    
    private BParslet parslet;
    
    private EntityResolver resolver;
    
    /** Creates a parser instance.
     * @param handler handler interface implementation (never <code>null</code>
     * @param resolver SAX entity resolver implementation or <code>null</code>.
     * It is recommended that it could be able to resolve at least the DTD.@param parslet convertors implementation (never <code>null</code>
     *
     *
     */
    public BParser(final BHandler handler, final EntityResolver resolver, final BParslet parslet) {
        this.parslet = parslet;
        this.handler = handler;
        this.resolver = resolver;
        buffer = new StringBuffer(111);
        context = new java.util.Stack();
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void characters(char[] chars, int start, int len) throws SAXException {
        buffer.append(chars, start, len);handler.characters(chars, start, len);
    }
    
    private void dispatch(final boolean fireOnlyIfMixed) throws SAXException {
        if (fireOnlyIfMixed && buffer.length() == 0) return; //skip it
        
        Object[] ctx = (Object[]) context.peek();
        String here = (String) ctx[0];
        Attributes attrs = (Attributes) ctx[1];
        if ("Descript".equals(here)) {
            if (fireOnlyIfMixed) throw new IllegalStateException("Unexpected characters() event! (Missing DTD?)");
            handler.handle_Descript(buffer.length() == 0 ? null : buffer.toString(), attrs);
        } else if ("Price".equals(here)) {
            if (fireOnlyIfMixed) throw new IllegalStateException("Unexpected characters() event! (Missing DTD?)");
            handler.handle_Price(parslet.priceToInt(buffer.length() == 0 ? null : buffer.toString()), attrs);
        } else if ("Custom".equals(here)) {
            handler.handle_Custom(buffer.length() == 0 ? null : buffer.toString(), attrs);
        } else if ("x-include".equals(here)) {
            if (fireOnlyIfMixed) throw new IllegalStateException("Unexpected characters() event! (Missing DTD?)");
            handler.handle_x_include(buffer.length() == 0 ? null : buffer.toString(), attrs);
        } else if ("inc-level-2".equals(here)) {
            if (fireOnlyIfMixed) throw new IllegalStateException("Unexpected characters() event! (Missing DTD?)");
            handler.handle_inc_level_2(buffer.length() == 0 ? null : buffer.toString(), attrs);
        } else {
            //do not care
        }
        buffer.delete(0, buffer.length());
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void endDocument() throws SAXException {
        handler.endDocument();
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void endElement(java.lang.String ns, java.lang.String name, java.lang.String qname) throws SAXException {
        dispatch(false);
        context.pop();
        if ("Custom".equals(name)) {
            handler.end_Custom();
        } else if ("Product".equals(name)) {
            handler.end_productHandlerMethod();
        } else if ("Books".equals(name)) {
            handler.end_Books();
        }
        handler.endElement(ns, name, qname);
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void endPrefixMapping(final java.lang.String prefix) throws SAXException {
        handler.endPrefixMapping(prefix);
    }
    
    /** Creates default error handler used by this parser.
     * @return org.xml.sax.ErrorHandler implementation
     *
     *
     */
    protected ErrorHandler getDefaultErrorHandler() {
        return new ErrorHandler() {
            public void error(SAXParseException ex) throws SAXException  {
                if (context.isEmpty()) System.err.println("Missing DOCTYPE.");
                throw ex;
            }
            
            public void fatalError(SAXParseException ex) throws SAXException {
                throw ex;
            }
            
            public void warning(SAXParseException ex) throws SAXException {
                // ignore
            }
        };
        
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void ignorableWhitespace(char[] chars, int start, int len) throws SAXException {
        handler.ignorableWhitespace(chars, start, len);
    }
    
    /** The recognizer entry method taking an InputSource.
     * @param input InputSource to be parsed.
     * @throws java.io.IOException on I/O error.
     * @throws SAXException propagated exception thrown by a DocumentHandler.
     * @throws javax.xml.parsers.ParserConfigurationException a parser satisfining requested configuration can not be created.
     * @throws javax.xml.parsers.FactoryConfigurationRrror if the implementation can not be instantiated.
     *
     *
     */
    public void parse(final InputSource input) throws SAXException, javax.xml.parsers.ParserConfigurationException, java.io.IOException {
        parse(input, this);
    }
    
    /** The recognizer entry method taking a URL.
     * @param url URL source to be parsed.
     * @throws java.io.IOException on I/O error.
     * @throws SAXException propagated exception thrown by a DocumentHandler.
     * @throws javax.xml.parsers.ParserConfigurationException a parser satisfining requested configuration can not be created.
     * @throws javax.xml.parsers.FactoryConfigurationRrror if the implementation can not be instantiated.
     *
     *
     */
    public void parse(final java.net.URL url) throws SAXException, javax.xml.parsers.ParserConfigurationException, java.io.IOException {
        parse(new InputSource(url.toExternalForm()), this);
    }
    
    /** The recognizer entry method taking an Inputsource.
     * @param input InputSource to be parsed.
     * @throws java.io.IOException on I/O error.
     * @throws SAXException propagated exception thrown by a DocumentHandler.
     * @throws javax.xml.parsers.ParserConfigurationException a parser satisfining requested configuration can not be created.
     * @throws javax.xml.parsers.FactoryConfigurationRrror if the implementation can not be instantiated.
     *
     *
     */
    public static void parse(final InputSource input, final BHandler handler, final BParslet parslet) throws SAXException, javax.xml.parsers.ParserConfigurationException, java.io.IOException {
        parse(input, new BParser(handler, null, parslet));
    }
    
    /** The recognizer entry method taking a URL.
     * @param url URL source to be parsed.
     * @throws java.io.IOException on I/O error.
     * @throws SAXException propagated exception thrown by a DocumentHandler.
     * @throws javax.xml.parsers.ParserConfigurationException a parser satisfining requested configuration can not be created.
     * @throws javax.xml.parsers.FactoryConfigurationRrror if the implementation can not be instantiated.
     *
     *
     */
    public static void parse(final java.net.URL url, final BHandler handler, final BParslet parslet) throws SAXException, javax.xml.parsers.ParserConfigurationException, java.io.IOException {
        parse(new InputSource(url.toExternalForm()), handler, parslet);
    }
    
    private static void parse(final InputSource input, final BParser recognizer) throws SAXException, javax.xml.parsers.ParserConfigurationException, java.io.IOException {
        javax.xml.parsers.SAXParserFactory factory = javax.xml.parsers.SAXParserFactory.newInstance();
        factory.setValidating(true);  //the code was generated according DTD
        factory.setNamespaceAware(false);  //the code was generated according DTD
        XMLReader parser = factory.newSAXParser().getXMLReader();
        parser.setContentHandler(recognizer);
        parser.setErrorHandler(recognizer.getDefaultErrorHandler());
        if (recognizer.resolver != null) parser.setEntityResolver(recognizer.resolver);
        parser.parse(input);
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void processingInstruction(java.lang.String target, java.lang.String data) throws SAXException {
        handler.processingInstruction(target, data);
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void setDocumentLocator(Locator locator) {
        handler.setDocumentLocator(locator);
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void skippedEntity(java.lang.String name) throws SAXException {
        handler.skippedEntity(name);
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void startDocument() throws SAXException {
        handler.startDocument();
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void startElement(java.lang.String ns, java.lang.String name, java.lang.String qname, Attributes attrs) throws SAXException {
        dispatch(true);
        context.push(new Object[] {qname, new org.xml.sax.helpers.AttributesImpl(attrs)});
        if ("Custom".equals(name)) {
            handler.start_Custom(attrs);
        } else if ("Image".equals(name)) {
            handler.handle_Image(attrs);
        } else if ("Product".equals(name)) {
            handler.start_productHandlerMethod(attrs);
        } else if ("Books".equals(name)) {
            handler.start_Books(attrs);
        }
        handler.startElement(ns, name, qname, attrs);
    }
    
    /** This SAX interface method is implemented by the parser.
     *
     *
     */
    public final void startPrefixMapping(final java.lang.String prefix, final java.lang.String uri) throws SAXException {
        handler.startPrefixMapping(prefix, uri);
    }
    
    
}

=== Data Convertor Interfaces:

public interface BParslet {
    public java.awt.Image getImage(final java.lang.String data) throws SAXException;
    
    public java.lang.String getText(final java.lang.String data) throws SAXException;
    
    public int priceToInt(final java.lang.String data) throws SAXException;
    
    
}

=== Data Convertor Implementation:

public class BPImpl implements BParslet {
    public java.awt.Image getImage(final java.lang.String data) throws SAXException {
        throw new SAXException("Not implemented yet.");
    }
    
    public java.lang.String getText(final java.lang.String data) throws SAXException {
        throw new SAXException("Not implemented yet.");
    }
    
    public int priceToInt(final java.lang.String data) throws SAXException {
        try {
            return Integer.parseInt(data.trim());
        } catch (IllegalArgumentException ex) {
            throw new SAXException("priceToInt(" + data.trim() + ")", ex);
        }
    }
    
    
}
