//GEN-BEGIN:Client
/**
 * This file is generated. Please do not change
 */
<#assign packageName = mapping.getServerMapping().getPackageName()/>
package ${packageName};

import java.io.*;
import java.lang.reflect.*;
import java.util.*;

/**
 *  This class is used as an external protocol utility. It is so we don't
 *  generate as much code.
 */

public class Utility {

    /** Registered types */
    <#list instanceTypes as type>
        <#if type.getName() != "void">
            <#assign serializer = mapping.getRegistry().getTypeSerializer( type )/>
            private final static int ${serializer.instanceOf( type )?upper_case?replace( "[]", "_ARRAY" )?replace( ".", "_" ) }_TYPE = ${registry.getRegisteredTypeId( type )};
        </#if>
    </#list>

    /** Marker for null. Null is a type and a value together. */
    private final static short NULL_TYPE = -1;
    
    /** Marker for void return types. */
    public final static Object VOID_VALUE = new Object();
    
    /**
     * Sends return values to the client output stream.
     *
     * @param output The output stream into which all the data should be written
     * @param  returnValues The values which we should write into the stream
     * @throws IOException If an error occured while writing the results
     */
    public static void writeResults( DataOutput output, Object[] returnValues) throws IOException {
        for ( int i = 0; i < returnValues.length; i++ ) {
            writeObject(output, returnValues[i]);
        }
    }
    
<#list instanceTypes as type>
    <#if type.isPrimitive() && type.getName() != "void">
    static Object toObject( ${type.getName()} value ) {
        return ${registry.getTypeSerializer( type ).toObject( type, "value" )};
    }

    </#if>
</#list>

    /**
     * 
     * @param output 
     * @param o 
     * @throws java.io.IOException 
     */
    public static void writeObject(DataOutput output, Object o) throws IOException {
        if (o == null) { // return null
            output.writeShort(NULL_TYPE);
        <#assign arrayTypeID = 0/>
        <#assign hasArrays = false/>
        <#list returnInstanceTypes as type>
            <#assign serializer = mapping.getRegistry().getTypeSerializer( type )/>
            <#if type.getName() != "void" && !type.isArray()>                
                } else if(o instanceof ${serializer.instanceOf( type )}) {
                    output.writeShort(${serializer.instanceOf( type )?upper_case?replace( "[]", "_ARRAY" )?replace( ".", "_" ) }_TYPE);                    
                    <#if type.isPrimitive()>
                        ${serializer.toStream( mapping, type, "output", serializer.fromObject( type, "o" ))}
                    <#else>
                        ${serializer.toStream( mapping, type, "output", "o" )}
                    </#if>
                    return;
            </#if>
            <#if type.isArray()>
                <#assign hasArrays = true/>
                <#assign arrayTypeID = registry.getRegisteredTypeId( type )/>
                <#assign arrayType = type/>
            </#if>
        </#list>
        <#if hasArrays>
            } else if(o.getClass().isArray()) {
            output.writeShort(${mapping.getRegistry().getTypeSerializer( arrayType ).instanceOf( arrayType )?upper_case?replace( "[]", "_ARRAY" ) }_TYPE);
            <#list returnTypes as type>
                <#if type.isArray() && type.getName() != "void">
                    if( o instanceof ${type.getName()}) {
                        ${type.getName()} array = (${type.getName()}) o;
                        output.writeShort(${mapping.getRegistry().getTypeSerializer( type.getComponentType()).instanceOf( type.getComponentType())?upper_case?replace( "[]", "_ARRAY" )?replace( ".", "_" ) }_TYPE);
                        output.writeInt(array.length);
                        for(int i = 0; i < array.length; i++) {
                            ${registry.getTypeSerializer( type.getComponentType()).toStream( mapping, type.getComponentType(), "output", "array[i]" )}
                        }
                    }
                </#if>
            </#list>
        </#if>
        }   
    }

    /**
     * 
     * @param in 
     * @return 
     * @throws java.io.IOException 
     */
    protected static Object readObject(DataInput in) throws IOException {
        short type = in.readShort();        
        Object result;
        switch (type) {
        <#assign arrayTypeID = 0/>
        <#assign hasArrays = false/>
        <#list parameterInstanceTypes as type>
            <#assign serializer = mapping.getRegistry().getTypeSerializer( type )/>
            <#if type.getName() != "void" && !type.isArray()>
                case ${serializer.instanceOf( type )?upper_case?replace( "[]", "_ARRAY" )?replace( ".", "_" ) }_TYPE:
                    ${serializer.fromStream( mapping, type, "in", "result" )}
                    return result;
            </#if>
            <#if type.isArray()>
                <#assign hasArrays = true/>
                <#assign arrayTypeID = registry.getRegisteredTypeId( type )/>
            </#if>
        </#list>
        <#if hasArrays>
            case ${mapping.getRegistry().getTypeSerializer( arrayType ).instanceOf( arrayType )?upper_case?replace( "[]", "_ARRAY" ) }_TYPE:
                short elementType = in.readShort();
                int length = in.readInt();
                switch (elementType) {
                <#list returnTypes as type>
                    <#assign serializer = mapping.getRegistry().getTypeSerializer( type )/>
                    <#if type.isArray() && type.getName() != "void">
                        case ${serializer.instanceOf( type )?upper_case?replace( "[]", "_ARRAY" )?replace( ".", "_" ) }_TYPE:
                            ${type.getName()} data = new ${type.getComponentType().getName()}[length];
                            for (int i = 0; i < length; i++) {
                                ${registry.getTypeSerializer( type.getComponentType()).fromStream( mapping, type.getComponentType(), "in", "data[i]" )}
                            }
                            return data;
                    </#if>
                </#list>
                }
        </#if>
            case NULL_TYPE: /* null */
                return null;
            default:
                throw new IllegalArgumentException(
                    "Unsupported return type (" + type + ")");
        }
    }
}
//GEN-END:Client