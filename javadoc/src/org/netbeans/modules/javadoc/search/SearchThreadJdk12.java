/*
 *                 Sun Public License Notice
 * 
 * The contents of this file are subject to the Sun Public License
 * Version 1.0 (the "License"). You may not use this file except in
 * compliance with the License. A copy of the License is available at
 * http://www.sun.com/
 * 
 * The Original Code is Forte for Java, Community Edition. The Initial
 * Developer of the Original Code is Sun Microsystems, Inc. Portions
 * Copyright 1997-2000 Sun Microsystems, Inc. All Rights Reserved.
 */

package com.netbeans.developer.modules.javadoc.search;

import java.util.StringTokenizer;
import java.util.ResourceBundle;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;

import javax.swing.text.html.parser.ParserDelegator;
import javax.swing.DefaultListModel;
import javax.swing.text.html.HTMLEditorKit;
import javax.swing.text.html.HTML;
import javax.swing.text.MutableAttributeSet;

import com.netbeans.ide.util.NbBundle;
import com.netbeans.ide.filesystems.FileObject;

/** This class implements the index search through documenation 
 * generated by Jdk 1.2 standard doclet
 */

class SearchThreadJdk12 extends IndexSearchThread {

  private BufferedReader    in;
  private URL               contextURL;

  private boolean  stopSearch = false;

  public SearchThreadJdk12 ( String toFind, 
                             FileObject fo, 
                             IndexSearchThread.DocIndexItemConsumer diiConsumer ) {
      
    super( toFind, fo, diiConsumer );
    
    if ( fo.isFolder() ) {
      // Documentation uses splited index - resolve the right file
      Integer fileNumber = new Integer( (int)(Character.toUpperCase( toFind.charAt(0) ))  - 'A' + 1);

      if ( fileNumber.intValue() < 1 || fileNumber.intValue() > 26 ) {
        fileNumber = new Integer( 27 );
      }

      String fileName = new String( "index-" + fileNumber.toString() );
      this.fo = fo.getFileObject( fileName, "html" );

      try {
        contextURL = this.fo.getURL();
      }
      catch ( com.netbeans.ide.filesystems.FileStateInvalidException e ) {
        throw new InternalError( "Can't create documentation folder URL - file state invalid" );
      }
    }
  }

  public void stopSearch() {
    stopSearch = true;
    try {
      in.close();
    }
    catch ( java.io.IOException e ) {
      System.out.println (" Can't close stream " );
    }
  }

  public void run () {
    //System.out.println ( "START RUNNING :" + fo );

    ParserDelegator pd = new ParserDelegator();

    if ( fo == null || toFind == null )
      return;

    try {
      in = new BufferedReader( new InputStreamReader( fo.getInputStream () ));
      pd.parse( in, new SearchCallbackJdk12(), true );
      in.close();
    }
    catch ( java.io.IOException e ) {
      // Do nothing
    }
    //is.searchEnded();
    //System.out.println ("THE REAL END");
    taskFinished();
  }

  // Inner classes ------------------------------------------------------------------------------------


  /* These are constants for the inner class */

  /** Source of the localized human presentable strings. */
  static ResourceBundle bundle = NbBundle.getBundle(SearchThreadJdk12.class);

  static private final String STR_CLASS = bundle.getString( "JDK12_CLASS" );
  static private final String STR_INTERFACE = bundle.getString( "JDK12_INTERFACE" );
  static private final String STR_CONSTRUCTOR = bundle.getString( "JDK12_CONSTRUCTOR" );
  static private final String STR_METHOD = bundle.getString( "JDK12_METHOD" );
  static private final String STR_VARIABLE = bundle.getString( "JDK12_VARIABLE" );
  static private final String STR_STATIC = bundle.getString( "JDK12_STATIC" );
  static private final String STR_DASH = bundle.getString( "JDK12_DASH" );
  static private final String STR_PACKAGE = bundle.getString( "JDK12_PACKAGE" );
  
  /*
  static {
    bundle = NbBundle.getBundle(SearchThreadJdk12.class);
    STR_CLASS = bundle.getString( "JDK12_CLASS" );
    STR_INTERFACE = bundle.getString( "JDK12_INTERFACE" );
    STR_CONSTRUCTOR = bundle.getString( "JDK12_CONSTRUCTOR" );
    STR_METHOD = bundle.getString( "JDK12_METHOD" );
    STR_VARIABLE = bundle.getString( "JDK12_VARIABLE" );
    STR_STATIC = bundle.getString( "JDK12_STATIC" );
    STR_DASH = bundle.getString( "JDK12_DASH" );
    STR_PACKAGE = bundle.getString( "JDK12_PACKAGE" );
  }
  */

  static private final int IN_BALAST = 0;
  static private final int IN_DT = 1;
  static private final int IN_AREF = 2;
  static private final int IN_B = 3;
  static private final int IN_DESCRIPTION = 4;
  static private final int IN_DESCRIPTION_SUFFIX = 5;

  /** This inner class parses the JDK 1.2 Documentation index and returns 
   *  found indexItems
   */

  private class SearchCallbackJdk12 extends HTMLEditorKit.ParserCallback {
      
    private String              hrefVal;
    private DocIndexItem        currentDii = null;           
    private int                 where = IN_BALAST;

    int printText = 0;

    public void handleStartTag(HTML.Tag t, MutableAttributeSet a, int pos) {

      if ( t == HTML.Tag.DT ) {
        where = IN_DT;
      }
      else if ( t == HTML.Tag.A && where == IN_DT ) {
        where = IN_AREF;
        Object val = a.getAttribute( HTML.Attribute.HREF );
        if ( val != null ) {
          hrefVal = (String) val.toString();  
        }
      }
      else if ( t == HTML.Tag.A && where == IN_DESCRIPTION_SUFFIX ) {
        ; // Just ignore 
      }
      else if ( t == HTML.Tag.B && where == IN_AREF ) {
        where = IN_AREF;
      }
      else {
        where = IN_BALAST;
      }
    }

    public void handleText(char[] data, int pos) {
      
      if ( where == IN_AREF ) {
        String text = new String( data );
        if ( text.startsWith( toFind ) ) {
          DocIndexItem dii = new DocIndexItem( text, null, contextURL, hrefVal );
          insertDocIndexItem( dii );
          currentDii = dii;
          where = IN_DESCRIPTION;
        }
      }
      else if ( where == IN_DESCRIPTION  ) {
        String text = new String( data );


        // Stop suffering if we are behind the searched words
        if ( text.substring( 0, Math.min(toFind.length(), text.length()) ).compareTo( toFind ) > 0 ) {
          try {
            in.close();
          }
          catch ( java.io.IOException e ) {
            System.out.println ( "Can't close stream" );
          }
        }

        currentDii.setRemark( text );
        text = text.toUpperCase();
        
        StringTokenizer st = new StringTokenizer( text );
        String token = st.nextToken();
        if ( token.equals( STR_DASH ) )
          token = st.nextToken();

        boolean isStatic = false;
        
        if ( token.equals( STR_STATIC ) ) {
          isStatic = true;
          token = st.nextToken();
        }
         
        if ( token.equals( STR_CLASS ) )
          currentDii.setIconIndex( DocSearchIcons.ICON_CLASS );
        else if ( token.equals( STR_INTERFACE ) )
          currentDii.setIconIndex( DocSearchIcons.ICON_INTERFACE );
        else if ( token.equals( STR_PACKAGE ) )
          currentDii.setIconIndex( DocSearchIcons.ICON_PACKAGE );
        else if ( token.equals( STR_CONSTRUCTOR ) )
          currentDii.setIconIndex( DocSearchIcons.ICON_CONSTRUCTOR );
        else if ( token.equals( STR_METHOD ) )
          currentDii.setIconIndex( isStatic ? DocSearchIcons.ICON_METHOD_ST : DocSearchIcons.ICON_METHOD );
        else if ( token.equals( STR_VARIABLE ) )
          currentDii.setIconIndex( isStatic ? DocSearchIcons.ICON_VARIABLE_ST : DocSearchIcons.ICON_VARIABLE );     
   
        if ( text.endsWith( "." ) )
          where = IN_DESCRIPTION_SUFFIX;
        else
          where = IN_BALAST;
      }
      else if ( where == IN_DESCRIPTION_SUFFIX ) {
        currentDii.setRemark( currentDii.getRemark() + new String( data ));
      } 
      else 
        where = IN_BALAST;
      
    }
    
  }
        /*
        if ( text.substring( 0, Math.min(toFind.length(), text.length()) ).compareTo( toFind ) > 0 ) {
          try {
            in.close();
          }
          catch ( java.io.IOException e ) {
            System.out.println ( "Can't close stream" );
          }
        }
        
      }
      
      where = IN_BALAST;
    }  
  }
    */
}

